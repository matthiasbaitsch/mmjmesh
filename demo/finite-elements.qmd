# Shape functions and finite elements

```{julia}
#| echo: false
#| warning: false
include("setup.jl")
using IntervalSets
using LinearAlgebra
using WGLMakie
using CairoMakie
using DomainSets
CairoMakie.activate!()
```

## Shape functions

Hermite like polynomials with middle node

```{julia}
h = 2.0
N = [ValueAtLF.(0:h/2:h); DerivativeAtLF.([0, h])] |> vcat
P = monomials(0:length(N)-1, 0 .. h)
M = [n(p) for p in P, n in N]
H = inv(M) * P
fplot(H...)
```

Bilinear shape functions

```{julia}
V = [-1 1 1 -1; -1 -1 1 1]
N = [ValueAtLF(p) for p in eachcol(V)]
P = mmonomials(2, 1, QHat)
M = [n(p) for p in P, n in N]
H = inv(M) * P

fplot3d(H)
```

Serendipity shape functions

```{julia}
V = [-1 0 1 1 1 0 -1 -1; -1 -1 -1 0 1 1 1 0]
P = mmonomials(
    2, 2,
    QHat,
    predicate=(p1, p2) -> p1 + p2 < 4
)
N = [ValueAtLF(p) for p in eachcol(V)]
M = [n(p) for p in P, n in N]
H = inv(M) * P

fplot3d(H)
```

Conforming rectangular plate element shape functions

```{julia}
V = [-1.0 1 1 -1; -1 -1 1 1]
P = mmonomials(
    2, 3,
    QHat
)
N = vcat(
    [
        [
            ValueAtLF(p),
            PDerivativeAtLF(p, [1, 0]),
            PDerivativeAtLF(p, [0, 1]),
            PDerivativeAtLF(p, [1, 1])
        ]
        for p in eachcol(V)
    ]...
)
M = [n(p) for p in P, n in N]
H = inv(M) * P

fplot3d(H)
```

