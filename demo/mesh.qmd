# The Mesh interface

This chapter is incomplete and probably not worth reading.

```{julia}
#| echo: false
#| warning: false
include("setup.jl")
```

## Basic usage

Create mesh

```{julia}
coords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]
elts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]
m = Mesh(coords, elts, 2)
mplot(m) |> mconf()
```

Coordinates of a node

```{julia}
coordinates(node(m, 2))
```

Coordinates of a face

```{julia}  
coordinates(face(m, 3))
```

Process faces and print node and edge indexes

```{julia}
for e âˆˆ elements(m)
    println(e)
    println("- ", nodeIdxs(e))
    println("- ", edgeIdxs(e))
    println("- ", faceIdxs(e))
end
```

## Read mesh from Gmsh file

```{julia}
m = Mesh(meshpath("complex-g1.msh"))
mplot(m, edgesvisible=true) |> mconf()
```

## Groups and predefined groups

Mesh entities can be collected in groups some of which are predefined.

```{julia}
keys(m.groups.recipes)
```

```{julia}
show(m.groups[:boundarynodes])
```

Groups can be used to filter access

```{julia}
m = Mesh(meshpath("complex-g1.msh"))
p = mplot(m)
cm.scatter!(p.axis, coordinates(m, :boundarynodes), color = :hotpink)
p |> mconf()
```

Additional groups can be defined

```{julia}
using MMJMesh.Groups
m.groups[:f1] = FaceGroup(100:300)
m.groups[:f2] = FaceGroup(200:600)
m.groups[:e1] = EdgeGroup(600:800)
m.groups[:e2] = EdgeGroup(700:900)
mplot(m) |> mconf()
```

## Data

Example how to attach data to groups.

```{julia}
m = Mesh(meshpath("complex-g1.msh"))

println("s1: ", m.groups[:s1].indexes)
println("s2: ", m.groups[:s2].indexes)
println("s3: ", m.groups[:s3].indexes)

m.data[:kefunc, :s1] = "f1";
m.data[:kefunc, :s2] = "f2";
m.data[:kefunc, :s3] = "f3";

e0005 = element(m, 0005)
e0490 = element(m, 0490)
e1132 = element(m, 1132)

println("e0005.data[:kefunc] = ", e0005.data[:kefunc])
println("e0490.data[:kefunc] = ", e0490.data[:kefunc])
println("e1132.data[:kefunc] = ", e1132.data[:kefunc])
```
