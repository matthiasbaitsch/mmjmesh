# Mathematics

```{julia}
#| echo: false
#| warning: false
include("setup.jl")
using IntervalSets
using LinearAlgebra
using WGLMakie
using CairoMakie
CairoMakie.activate!()
```


## Mappings

```{julia}
f = Sin() ∘ (1 / Polynomial(0, 1, d=0.0 .. 0.05))
fplot(f, yscale=0.05, npoints=11)
```

```{julia}
s = Sin(0 .. 3π)
c = Cos(0 .. 3π)

f = 2s
g = s + f'
p = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])

fplot(c, s, g, p)
```

```{julia}
f = Polynomial([0, 1], -1 .. 1)
F = antiderivative(f)
fplot(f, F)
```

```{julia}
integrate(f, 0 .. 1)
```

```{julia}
p = [0, 1, 2]
f = fplot(fromroots(p, -0.1 .. 2.1))
cm.scatter!(p, 0 * p, color=:tomato)
f
```

```{julia}
p = [0, 1.5, 2]
f = fplot(lagrangepolynomials(p, 0 .. 2)...)
cm.scatter!(p, [0, 0, 0], color=:tomato)
cm.scatter!(p, [1, 1, 1], color=:blue)
f
```

### Parametric curves

Lissajous curve

```{julia}
u = ParametricCurve(Cos(0 .. 2π), Sin() ∘ Polynomial(0, 2, d=0 .. 2pi))
v = 0.075 * Sin() ∘ Polynomial(0, 100) * UnitNormal(u)
w = 0.025 * ParametricCurve(Sin(), Cos()) ∘ Polynomial(0, 200)
fplot(u, u + v, u + w)
```

```{julia}
pts = tomatrix([[0.0, 0], [1.5, 1], [2, 0], [1.5, -1], [0, 0]])
fig, ax = fplot(Interpolation(pts, 1))
cm.scatter!(ax, pts, color=:tomato)
fig
```


### Monomials

```{julia}
fplot(monomials(0:100, 0 .. 1)...)
```


### Hermite like polynomials with middle node

Compute polynomials

```{julia}
h = 2.0
N = [ValueAtLF.(0:h/2:h); DerivativeAtLF.([0, h])] |> vcat
P = monomials(0:length(N)-1, 0 .. h)
M = [n(p) for p in P, n in N]
H = inv(M) * P
fplot(H...)
```

## Functions of two variables

This part is in a very early stage of development.

Create the function $f : [0, 5\pi]^2 \to \mathbb{R}, \quad f(\mathbf{x}) = \sin x_1 \sin x_2$

```{julia}
f = makefunction(x -> sin(x[1]) * sin(x[2]), 0 .. 5π, 0 .. 5π);
```

By default the plot is a view down from positive $z$ direction

```{julia}
fplot3d(f, mesh=9)
```

Create a 3D plot using `Axis3` and switch of the mesh off since `CairoMakie` does not handle hidden lines.

```{julia}
fig = Figure()
ax3d = Axis3(fig[1, 1])
fplot3d!(ax3d, f, npoints=250, mesh=nothing)
fig
```

A (sometimes?) interactive 3D plot is obtained using WebGL:

```{julia}
WGLMakie.activate!()
fig = Figure()
ax3d = Axis3(fig[1, 1])
fplot3d!(ax3d, f, mesh=19, npoints=250)
fig
```

Multivariate polynomial

```{julia}
g = MPolynomial([2 1; 0 1], [1.0, -1.0], ReferenceQuadrilateral)
fig = Figure()
Axis3(fig[1, 1])
fplot3d!(g)
fig
```

Multivariate monomials

```{julia}
fplot3d(mmonomials(2, 3, ReferenceQuadrilateral))
```

Bilinear functions

```{julia}
V = [-1 1 1 -1; -1 -1 1 1]
N = [ValueAtLF(p) for p in eachcol(V)]
P = mmonomials(2, 1, ReferenceQuadrilateral)
M = [n(p) for p in P, n in N]
H = inv(M) * P

fplot3d(H)
```

Serendipity shape functions
```{julia}
V = [-1 0 1 1 1 0 -1 -1; -1 -1 -1 0 1 1 1 0]
P = mmonomials(
    2, 2,
    ReferenceQuadrilateral,
    predicate=(p1, p2) -> p1 + p2 < 4
)
N = [ValueAtLF(p) for p in eachcol(V)]
M = [n(p) for p in P, n in N]
H = inv(M) * P

fplot3d(H)
```