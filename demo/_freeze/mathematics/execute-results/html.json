{
  "hash": "055a8e0e90328b038cdac8745318b404",
  "result": {
    "engine": "jupyter",
    "markdown": "# Mathematics\n\n\n\n## Mappings\n\n::: {#54640b2a .cell execution_count=2}\n``` {.julia .cell-code}\nf = Sin() ∘ (1 / Polynomial(0, 1, d=0.0 .. 0.05))\nfplot(f, yscale=0.05, npoints=11)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](mathematics_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n::: {#28c081e5 .cell execution_count=3}\n``` {.julia .cell-code}\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nfplot(c, s, g, p)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](mathematics_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n::: {#83833ea7 .cell execution_count=4}\n``` {.julia .cell-code}\nf = Polynomial([0, 1], -1 .. 1)\nF = antiderivative(f)\nfplot(f, F)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](mathematics_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n::: {#29ce31f7 .cell execution_count=5}\n``` {.julia .cell-code}\nintegrate(f, 0 .. 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n0.5\n```\n:::\n:::\n\n\n::: {#8ef6a902 .cell execution_count=6}\n``` {.julia .cell-code}\np = [0, 1, 2]\nf = fplot(fromroots(p, -0.1 .. 2.1))\ncm.scatter!(p, 0 * p, color=:tomato)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](mathematics_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n::: {#2f81a766 .cell execution_count=7}\n``` {.julia .cell-code}\np = [0, 1.5, 2]\nf = fplot(lagrangepolynomials(p, 0 .. 2)...)\ncm.scatter!(p, [0, 0, 0], color=:tomato)\ncm.scatter!(p, [1, 1, 1], color=:blue)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](mathematics_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\n### Monomials\n\n::: {#2b50a0c1 .cell execution_count=8}\n``` {.julia .cell-code}\nfplot(monomials(0:100, 0 .. 1)...)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](mathematics_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\n### Hermite like polynomials with middle node\n\nDefine linear forms\n\n::: {#d2673ec9 .cell execution_count=9}\n``` {.julia .cell-code}\nimport MMJMesh.Mathematics.valueat\n\nstruct ValueAtLF <: AbstractMapping{FunctionRToR,Real,Any}\n    x::Real\nend\nvalueat(u::ValueAtLF, f::FunctionRToR) = f(u.x)\n\nstruct DerivativeAtLF <: AbstractMapping{FunctionRToR,Real,Any}\n    x::Real\nend\nvalueat(u::DerivativeAtLF, f::FunctionRToR) = f'(u.x)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nvalueat (generic function with 13 methods)\n```\n:::\n:::\n\n\nCompute polynomials\n\n::: {#65b1d9b3 .cell execution_count=10}\n``` {.julia .cell-code}\nh = 2.0\nN = [ValueAtLF.(0:h/2:h); DerivativeAtLF.([0, h])] |> vcat\nP = monomials(0:length(N)-1, 0 .. h)\nM = [n(p) for p in P, n in N]\nH = inv(M) * P\nfplot(H...)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](mathematics_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "mathematics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}