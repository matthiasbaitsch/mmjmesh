{
  "hash": "651db62b14ec631fd441203d7c5e4723",
  "result": {
    "engine": "jupyter",
    "markdown": "# Mathematics\n\n\n\n## Mappings\n\n::: {#2f841f2f .cell execution_count=2}\n``` {.julia .cell-code}\nf = Sin() ∘ (1 / Polynomial(0, 1, d=0.0 .. 0.05))\nfplot(f, yscale=0.05, npoints=11)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](mathematics_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n::: {#706fda87 .cell execution_count=3}\n``` {.julia .cell-code}\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nfplot(c, s, g, p)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](mathematics_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n::: {#9967477c .cell execution_count=4}\n``` {.julia .cell-code}\nf = Polynomial([0, 1], -1 .. 1)\nF = antiderivative(f)\nfplot(f, F)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](mathematics_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n::: {#630f9aa3 .cell execution_count=5}\n``` {.julia .cell-code}\nintegrate(f, 0 .. 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n0.5\n```\n:::\n:::\n\n\n::: {#48fd691f .cell execution_count=6}\n``` {.julia .cell-code}\np = [0, 1, 2]\nf = fplot(fromroots(p, -0.1 .. 2.1))\ncm.scatter!(p, 0 * p, color=:tomato)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](mathematics_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n::: {#230e74f4 .cell execution_count=7}\n``` {.julia .cell-code}\np = [0, 1.5, 2]\nf = fplot(lagrangepolynomials(p, 0 .. 2)...)\ncm.scatter!(p, [0, 0, 0], color=:tomato)\ncm.scatter!(p, [1, 1, 1], color=:blue)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](mathematics_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\n### Parametric curves\n\nLissajous curve\n\n::: {#eb9c2087 .cell execution_count=8}\n``` {.julia .cell-code}\nu = ParametricCurve(Cos(0 .. 2π), Sin() ∘ Polynomial(0, 2, d=0 .. 2pi))\nv = 0.075 * Sin() ∘ Polynomial(0, 100) * UnitNormal(u)\nw = 0.025 * ParametricCurve(Sin(), Cos()) ∘ Polynomial(0, 200)\nfplot(u, u + v, u + w)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](mathematics_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\n::: {#d7506eb4 .cell execution_count=9}\n``` {.julia .cell-code}\npts = tomatrix([[0.0, 0], [1.5, 1], [2, 0], [1.5, -1], [0, 0]])\nfig, ax = fplot(Interpolation(pts, 1))\ncm.scatter!(ax, pts, color=:tomato)\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](mathematics_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n### Monomials\n\n::: {#4786486d .cell execution_count=10}\n``` {.julia .cell-code}\nfplot(monomials(0:100, 0 .. 1)...)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](mathematics_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n### Hermite like polynomials with middle node\n\nDefine linear forms\n\n::: {#dd42488d .cell execution_count=11}\n``` {.julia .cell-code}\nimport MMJMesh.Mathematics.valueat\n\nstruct ValueAtLF <: AbstractMapping{FunctionRToR,Real,Any}\n    x::Real\nend\nvalueat(u::ValueAtLF, f::FunctionRToR) = f(u.x)\n\nstruct DerivativeAtLF <: AbstractMapping{FunctionRToR,Real,Any}\n    x::Real\nend\nvalueat(u::DerivativeAtLF, f::FunctionRToR) = f'(u.x)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nvalueat (generic function with 16 methods)\n```\n:::\n:::\n\n\nCompute polynomials\n\n::: {#ba65f2c2 .cell execution_count=12}\n``` {.julia .cell-code}\nh = 2.0\nN = [ValueAtLF.(0:h/2:h); DerivativeAtLF.([0, h])] |> vcat\nP = monomials(0:length(N)-1, 0 .. h)\nM = [n(p) for p in P, n in N]\nH = inv(M) * P\nfplot(H...)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](mathematics_files/figure-html/cell-13-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "mathematics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}