{
  "hash": "bcc4bfc282d1e504169fa49d09d8b41f",
  "result": {
    "engine": "jupyter",
    "markdown": "# Mathematics\n\n\n\n## Mappings\n\n::: {#95843c29 .cell execution_count=2}\n``` {.julia .cell-code}\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nfplot(c, s, g, p)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](mathematics_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n::: {#9c20e6ad .cell execution_count=3}\n``` {.julia .cell-code}\nf = Polynomial([0, 1], -1 .. 1)\nF = antiderivative(f)\nfplot(f, F)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](mathematics_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n::: {#1c2302a9 .cell execution_count=4}\n``` {.julia .cell-code}\nintegrate(f, 0 .. 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n0.5\n```\n:::\n:::\n\n\n::: {#3217d66c .cell execution_count=5}\n``` {.julia .cell-code}\np = [0, 1, 2]\nf = fplot(fromroots(p, -0.1 .. 2.1))\ncm.scatter!(p, 0 * p, color=:tomato)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](mathematics_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n::: {#172cfceb .cell execution_count=6}\n``` {.julia .cell-code}\np = [0, 1.5, 2]\nf = fplot(lagrangepolynomials(p, 0 .. 2)...)\ncm.scatter!(p, [0, 0, 0], color=:tomato)\ncm.scatter!(p, [1, 1, 1], color=:blue)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](mathematics_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n### Monomials\n\n::: {#88d458b9 .cell execution_count=7}\n``` {.julia .cell-code}\nfplot(monomials(0:100, 0 .. 1)...)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](mathematics_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\n### Hermite like polynomials with middle node\n\nDefine linear forms\n\n::: {#dda94016 .cell execution_count=8}\n``` {.julia .cell-code}\nimport MMJMesh.Mathematics.valueat\n\nstruct ValueAtLF <: AbstractMapping{FunctionRToR,Real,All}\n    x::Real\nend\nvalueat(u::ValueAtLF, f::FunctionRToR) = f(u.x)\n\nstruct DerivativeAtLF <: AbstractMapping{FunctionRToR,Real,All}\n    x::Real\nend\nvalueat(u::DerivativeAtLF, f::FunctionRToR) = f'(u.x)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nvalueat (generic function with 11 methods)\n```\n:::\n:::\n\n\nCompute polynomials\n\n::: {#0de5bd79 .cell execution_count=9}\n``` {.julia .cell-code}\nh = 2.0\nN = [ValueAtLF.(0:h/2:h); DerivativeAtLF.([0, h])] |> vcat\nP = monomials(0:length(N)-1, 0 .. h)\nM = [n(p) for p in P, n in N]\nH = inv(M) * P\nfplot(H...)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](mathematics_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "mathematics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}