{
  "hash": "6596d1956ce92fd2275a4c8c6a73ba24",
  "result": {
    "engine": "jupyter",
    "markdown": "# Mathematics\n\n\n\n## Mappings\n\n::: {#9e1230b0 .cell execution_count=2}\n``` {.julia .cell-code}\nf = Sin() ∘ (1 / Polynomial(0, 1, d=0.0 .. 0.05))\nfplot(f, yscale=0.05, npoints=11)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](mathematics_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n::: {#39cc6d52 .cell execution_count=3}\n``` {.julia .cell-code}\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nfplot(c, s, g, p)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](mathematics_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n::: {#b52535c0 .cell execution_count=4}\n``` {.julia .cell-code}\nf = Polynomial([0, 1], -1 .. 1)\nF = antiderivative(f)\nfplot(f, F)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](mathematics_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n::: {#19aae8ca .cell execution_count=5}\n``` {.julia .cell-code}\nintegrate(f, 0 .. 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n0.5\n```\n:::\n:::\n\n\n::: {#9f7ce756 .cell execution_count=6}\n``` {.julia .cell-code}\np = [0, 1, 2]\nf = fplot(fromroots(p, -0.1 .. 2.1))\ncm.scatter!(p, 0 * p, color=:tomato)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](mathematics_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n::: {#57531f5d .cell execution_count=7}\n``` {.julia .cell-code}\np = [0, 1.5, 2]\nf = fplot(lagrangepolynomials(p, 0 .. 2)...)\ncm.scatter!(p, [0, 0, 0], color=:tomato)\ncm.scatter!(p, [1, 1, 1], color=:blue)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](mathematics_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\n### Parametric curves\n\nLissajous curve\n\n::: {#0a743152 .cell execution_count=8}\n``` {.julia .cell-code}\nfplot(ParametricCurve(Cos(0 .. 2π), Sin() ∘ Polynomial(0, 2, d=0 .. 2pi)))\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](mathematics_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\n::: {#235d6f2c .cell execution_count=9}\n``` {.julia .cell-code}\nu = ParametricCurve(Cos(0 .. 2π), Sin() ∘ Polynomial(0, 2, d=0 .. 2pi))\ns = Sin() ∘ Polynomial(0, 100)\nn = UnitNormal(u)\nfplot(u + 0.025 * s * n)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](mathematics_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n### Monomials\n\n::: {#0a0284f6 .cell execution_count=10}\n``` {.julia .cell-code}\nfplot(monomials(0:100, 0 .. 1)...)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](mathematics_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n### Hermite like polynomials with middle node\n\nDefine linear forms\n\n::: {#cb2e7974 .cell execution_count=11}\n``` {.julia .cell-code}\nimport MMJMesh.Mathematics.valueat\n\nstruct ValueAtLF <: AbstractMapping{FunctionRToR,Real,Any}\n    x::Real\nend\nvalueat(u::ValueAtLF, f::FunctionRToR) = f(u.x)\n\nstruct DerivativeAtLF <: AbstractMapping{FunctionRToR,Real,Any}\n    x::Real\nend\nvalueat(u::DerivativeAtLF, f::FunctionRToR) = f'(u.x)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nvalueat (generic function with 15 methods)\n```\n:::\n:::\n\n\nCompute polynomials\n\n::: {#8366b961 .cell execution_count=12}\n``` {.julia .cell-code}\nh = 2.0\nN = [ValueAtLF.(0:h/2:h); DerivativeAtLF.([0, h])] |> vcat\nP = monomials(0:length(N)-1, 0 .. h)\nM = [n(p) for p in P, n in N]\nH = inv(M) * P\nfplot(H...)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](mathematics_files/figure-html/cell-13-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "mathematics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}