{
  "hash": "a641cc3c5d5e8e08dd78caea7a9d9f5f",
  "result": {
    "engine": "jupyter",
    "markdown": "# Introduction \n\nThe `MMJMesh` library is intended to become a simple yet versatile basis for the implementation of finite element methods or postprocessing tools. At the moment it is in a very early stage of development.\n\n## Demo for 1D meshes\n\nFirst, we need to load the required modules. Note that `CairoMakie` included by `import` and not by `using` in order to avoid name collissions.\n\n::: {#a1d03613 .cell execution_count=1}\n``` {.julia .cell-code}\nimport CairoMakie\nusing IntervalSets\nusing MMJMesh.Plots\nusing MMJMesh.Meshes\nusing MMJMesh.Utilities\nusing MMJMesh.Mathematics\n```\n:::\n\n\n\n\nIn the simplest case, a 1D mesh is defined by parameter bounds and the number of elements. \n\n::: {#70bd9fa3 .cell execution_count=3}\n``` {.julia .cell-code}\nm = makemeshoninterval(0.0, 8.0, 4)\nmplot(m) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\nElements of the mesh can be easily processed in a loop:\n\n::: {#decd4d62 .cell execution_count=4}\n``` {.julia .cell-code}\nfor e ∈ elements(m)\n    println(e, \" with n = \", nodeindices(e), \" and l = \", length(e))\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEdge{2, 2}[1] with n = [1, 2] and l = 2.0\nEdge{2, 2}[2] with n = [2, 3] and l = 2.0\nEdge{2, 2}[3] with n = [3, 4] and l = 2.0\nEdge{2, 2}[4] with n = [4, 5] and l = 2.0\n```\n:::\n:::\n\n\nVarious functions like `nodeindices` and `length` exist to access properties. If you are used to an object-oriented language like Java it might be helpful to understand that `nodeindices(e)` in Julia is equivalent to `e.nodeindices()` in an OO language.\n\nNode coordinates are retrieved using the `coordinates` method:\n\n::: {#264404b9 .cell execution_count=5}\n``` {.julia .cell-code}\ncoordinates(m)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2×5 Matrix{Float64}:\n 0.0  2.0  4.0  6.0  8.0\n 0.0  0.0  0.0  0.0  0.0\n```\n:::\n:::\n\n\nProperties are associated with the mesh using the `data` field of the mesh and a name for the property in the form `:name`\n\n::: {#e6fd713c .cell execution_count=6}\n``` {.julia .cell-code}\nm.data[:foo] = 99\nm.data[:bar] = sqrt;\n```\n:::\n\n\nand then are ready to be used in a later stage\n\n::: {#4801e956 .cell execution_count=7}\n``` {.julia .cell-code}\nf = m.data[:bar]\nf(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n2.0\n```\n:::\n:::\n\n\nIn Julia, `:name` is called a symbol. In many applications, this is equivalent to the use of strings like `\"name\"`, however, easier to type.\n\nIt is easy to plot quantities for nodes\n\n::: {#978b8976 .cell execution_count=8}\n``` {.julia .cell-code}\nmplot(m, -1 .+ 2 * rand(nnodes(m))) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](index_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\nconstant on elements\n\n::: {#7c38555a .cell execution_count=9}\n``` {.julia .cell-code}\nmplot(m, -1 .+ 2 * rand(nelements(m))) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](index_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\nlinear on elements\n\n::: {#7bfd2cbd .cell execution_count=10}\n``` {.julia .cell-code}\nmplot(m, -1 .+ 2 * rand(2, nelements(m))) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](index_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\nfunctions on elements\n\n::: {#97c93775 .cell execution_count=11}\n``` {.julia .cell-code}\nmplot(m, [Polynomial(rand(-1 .. 1, 4), IHat) for _ ∈ 1:nelements(m)]) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](index_files/figure-html/cell-12-output-1.svg){}\n:::\n:::\n\n\nFurthermore, 1D meshes can be created with a parametric function\n\n::: {#f720f6fc .cell execution_count=12}\n``` {.julia .cell-code}\nm = makemeshoninterval(0, 5, 60, t -> [t; 0.3 * sin(π * t)])\nmplot(m) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](index_files/figure-html/cell-13-output-1.svg){}\n:::\n:::\n\n\nwhere the last parameter `t -> [t; sin(t)]` (read: `t` is mapped on the vector `(t, sin(t))`) defines the parametric curve\n\n$$\n    \\mathbf{u}(t) =\n    \\left(\n    \\begin{array}{c}\n        t\n        \\\\ \n        \\sin(t)\n    \\end{array}\n    \\right).\n$$\n\n## Demo for 2D meshes\n\nCreate mesh on rectangular grid\n\n::: {#5412ac92 .cell execution_count=13}\n``` {.julia .cell-code}\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nmplot(m) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](index_files/figure-html/cell-14-output-1.svg){}\n:::\n:::\n\n\nRead mesh from Gmsh\n\n::: {#92a10ba4 .cell execution_count=14}\n``` {.julia .cell-code}\nm = Mesh(\"../data/gmsh/advanced.msh\")\nmplot(m) |> mconf()\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![](index_files/figure-html/cell-15-output-1.svg){}\n:::\n:::\n\n\nIndices of nodes on boundary\n\n::: {#b9ef3302 .cell execution_count=15}\n``` {.julia .cell-code}\nm.groups[:boundarynodes]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n12-element NodeGroup:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  9\n 10\n 11\n 12\n 13\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}