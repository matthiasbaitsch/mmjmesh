# Finite elements

```{julia}
#| echo: false
#| warning: false
include("setup.jl")
using Latexify
using WGLMakie
using Symbolics
using CairoMakie
using IntervalSets
using LinearAlgebra
CairoMakie.activate!()
```

Variables and helper function

```{julia}
@variables a, b, x, y, l, EA, EI, ν

function prettyprint(name, factor, value)
    Nᵢ = name.s[2:end-1]
    Nⱼ = latexify(simplify(factor), env=:raw)
    s3 = latexify(simplify.(1 / factor * value, expand=true), env=:raw)
    return L"%$Nᵢ = %$Nⱼ %$s3"
end;
```

## Elements

```{julia}
fig = Figure(size=(700, 700))
Axis(fig)
feplot(fig[1, 1], makeelement(:lagrange, IHat, k=1)) |> feconf()
feplot(fig[1, 2], makeelement(:lagrange, IHat, k=3)) |> feconf()
feplot(fig[2, 1], makeelement(:hermite, IHat)) |> feconf()
feplot(fig[2, 2], makeelement(:lagrange, QHat, k=1)) |> feconf()
feplot(fig[3, 1], makeelement(:lagrange, QHat, k=2)) |> feconf()
feplot(fig[3, 2], makeelement(:serendipity, QHat, k=2)) |> feconf()
feplot(fig[4, 1], makeelement(:hermite, QHat, conforming=true)) |> feconf()
feplot(fig[4, 2], makeelement(:hermite, QHat, conforming=false)) |> feconf()
fig
```

## Shape functions

Linear shape functions

```{julia}
makeelement(:lagrange, IHat, k=1) |> nodalbasis |> fplot
```

Hermite polynomials

```{julia}
N = nodalbasis(makeelement(:hermite, 1 .. 4))
fig = Figure()
fplot!(Axis(fig[1, 1], title="Functions"), N...)
fplot!(Axis(fig[1, 2], title="Derivatives"), derivative.(N)...)
fig
```

Bilinear shape functions

```{julia}
#| echo: false
GLMakie.activate!()
```

```{julia}
makeelement(:lagrange, QHat, k=1) |> nodalbasis |> fplot3d
```

Serendipity shape functions

```{julia}
makeelement(:serendipity, (0 .. 2) × (0 .. 1), k=2) |> nodalbasis |> fplot3d
```

Conforming rectangular plate element shape functions

```{julia}
makeelement(:hermite, QHat) |> nodalbasis |> fplot3d
```

Quadratic serendipity shape functions on the domain $[0, a] \times [0, b]$

```{julia}
K = (0 .. a) × (0 .. b)
N = nodalbasis(makeelement(:serendipity, K, k=2))

prettyprint(L"\mathbf{N}(x, y)", 1 / (a^2 * b^2), [Nᵢ(x, y) for Nᵢ ∈ N])
```


## Finite element stiffness matrices

### Truss

```{julia}
N = nodalbasis(makeelement(:lagrange, IHat, k=1))
D(u) = 2 / l * u'
aᵉ(u, δu) = EA * l / 2 * integrate(D(u) * D(δu), IHat)
Kᵉ = [aᵉ(Nᵢ, Nⱼ) for Nᵢ ∈ N, Nⱼ ∈ N]

prettyprint(L"\mathbf{K}^e", EA / l, Kᵉ)
```

### Beam

```{julia}
N = [1, l / 2, 1, l / 2] .* nodalbasis(makeelement(:hermite, IHat))
D(w) = 4 / l^2 * w''
aᵉ(w, δw) = EI * l / 2 * integrate(D(w) * D(δw), IHat)
Kᵉ = [aᵉ(Nᵢ, Nⱼ) for Nᵢ ∈ N, Nⱼ ∈ N]

prettyprint(L"\mathbf{K}^e", EI / l^3, Kᵉ)
```

### 2D Poisson equation

Integration on the reference quadrilateral

```{julia}
N = nodalbasis(makeelement(:lagrange, QHat, k=1))
D(u) = [2 / a * ∂x(u), 2 / b * ∂y(u)]
aᵉ(u, δu) = a * b / 4 * integrate(D(u) ⋅ D(δu), QHat)
Kᵉ = [aᵉ(Nᵢ, Nⱼ) for Nᵢ ∈ N, Nⱼ ∈ N]

prettyprint(L"\mathbf{K}^e", 1 / (6 * a * b), Kᵉ)
```

Alternative derivation in physical coordinates

```{julia}
K = (0 .. a) × (0 .. b)
N = nodalbasis(makeelement(:lagrange, K, k=1))
aᵉ(u, δu) = integrate(∇(u) ⋅ ∇(δu), K)
Kᵉ = [aᵉ(Nᵢ, Nⱼ) for Nᵢ ∈ N, Nⱼ ∈ N]

prettyprint(L"\mathbf{K}^e", 1 / (6 * a * b), Kᵉ)
```

```{julia}
bᵉ(δu) = integrate(δu, K)
rᵉ = [bᵉ(Nᵢ) for Nᵢ ∈ N]

prettyprint(L"\mathbf{r}^e", a * b / 4, rᵉ)
```