---
engine: julia
---

# The Mesh interface

```{julia}
#| include: false
include("setup.jl")
```

## Making meshes

### Mesh by coordinates and connectivity.

```{julia}
coords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]
elts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]
m = Mesh(coords, elts, 2)
mplot(m) |> mconf()
```

### Build mesh incrementally

```{julia}
l = 80
h1 = 2
h2 = 12
nn = 21
ne = nn - 1
ne2 = ne รท 2

m = Mesh(1, 2)
is1 = addnodes!(m, [-l / 2, 0], [l / 2, 0], nn)
is2 = addnodes!(m, polynomialinterpolation([-l / 2, h1], [0, h2], [l / 2, h1]), nn)
addelements!(m, is1, is1 .+ 1, n=ne, group=:chord)
addelements!(m, is2, is2 .+ 1, n=ne, group=:chord)
addelements!(m, is1, is2, group=:vert)
addelements!(m, is2, is1 .+ 1, n=ne2, group=:diag)
addelements!(m, is1 .+ ne2, is2 .+ (ne2 + 1), n=ne2, group=:diag)

mplot(m, edgecolor=:groups, nodesvisible=true) |> mconf()
```

### Read mesh from Gmsh file

Specify meshfile generated by Gmsh:

```{julia}
m = Mesh(meshpath("complex-g1.msh"))
mplot(m, edgesvisible=true) |> mconf()
```

If an Gmsh input file (extension .geo) is given, the meshfile is generated automatically:

```{julia}
m = Mesh(meshpath("complex-g1.geo"))
mplot(m, edgesvisible=true) |> mconf()
```

As an alternative, one can pass the Gmsh input as string:

```{julia}
m = Mesh("""
    SetFactory("OpenCASCADE");
    Rectangle(1) = {0, 0, 0, 20, 10, 0};
    Rectangle(2) = {10, -5, 0, 5, 20, 0};
    Disk(3) = {20, 5, 0, 15, 5};
    BooleanUnion{
        Surface{1}; 
        Delete;
    }{
        Surface{2}; 
        Surface{3}; 
        Delete;
    }
    MeshSize{:} = 0.5;
    Mesh 2;
"""
)
mplot(m, edgesvisible=true) |> mconf()
```

## Working with meshes

A mesh consists of mesh entities:

| Entity Type | Parametric dimension      |
|-------------|---------------------------|
| Node        | 0                         |
| Edge        | 1                         |
| Face        | 2                         |
| Solid       | 3                         |
| Element     | Maximum dimension in mesh |

The Element type simply refers to the parts of the highest dimension present in the mesh. It is introduced in order to be compatible with common finite element terminology.

For the nodes of mesh or mesh entity `m`, the functions

-   `nnodes(m)`: Number of nodes

-   `node(m, n)`: Node `n`

-   `nodes(m)`: All nodes

-   `nodeindices(m)`: Indices of nodes

exist. There are similar functions for edges, faces, solids and elements. In addition, the functions `length(edge)` and `area(face)` exist.

Coordinates of the mesh or mesh entities are accessed using

-   `coordinates(m)`: All node coordinates in a matrix

-   `coordinates(m, n)`: Coordinates of node `n`

-   `coordinates(m, indices)`: Coordinates of nodes with `indices`

Here is an example

```{julia}
coords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]
elts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]
m = Mesh(coords, elts, 2)

e = element(m, 2)
println("Total node count: ", nnodes(m))
println("      Total area: ", sum(area.(faces(m))))
println("          Node 3: ", node(m, 3))
println("          Edge 8: ", edge(m, 8))
println("         Element: ", e)
println(" Edge of element: ", edge(e, 2))
println("    Node indices: ", nodeindices(e))
println("     Coordinates: ", coordinates(e))
println("     Coordinates: ", coordinates(e, 3))
```

A loop can be used to process specific entity types

```{julia}
for e = faces(m)
    println(e)
end
```

or all entities associated with the mesh

```{julia}
for e = entities(m)
    println(e)
end
```

or a mesh entity

```{julia}
for e = entities(face(m, 3))
    println(e)
end
```

Nodes can be selected based on a predicate.

```{julia}
m = Mesh(meshpath("complex-g1.msh"))
n1 = nodeindices(m, on(Point(0.75, 1)))
n2 = nodeindices(m, on(Segment([0.75, 0], [2, 0])))
n3 = nodeindices(m, on(VLine(0.5)))

p = mplot(m) |> mconf()
scatter!(coordinates(m, n1), color=:green)
scatter!(coordinates(m, n2), color=:hotpink)
scatter!(coordinates(m, n3), color=:orange)
p
```

In addition, a single can be identified as well.

```{julia}
nodeindex(m, on(Point(0.75, 1)))
```

## Collections of Entities: Groups

Mesh entities can be collected in groups some of which are predefined.

We take a look at a mesh generated by Gmsh. The input file [`complex-g1.geo`](https://github.com/matthiasbaitsch/mmjmesh/blob/main/data/gmsh/complex-g1.geo) defines the physical curve `c1 and`the three physical surfaces `s1`, `s2`, `s3`. When plotted, these are visualized by colors.

```{julia}
m = Mesh(meshpath("complex-g1.msh"))
mplot(m) |> mconf()
```

In the MMJMesh mesh, groups are represented by symbols. In addition to the group `:c1` of edges, MMJMesh defines the group `:c10` of nodes on the corresponding curve by appending a 0 to the name.

```{julia}
groupnames(m)
```

Furthermore, some groups are predefined by MMJMesh.

```{julia}
groupnames(m, predefined=true)
```

A group collects indices of entities in the group

```{julia}
show(group(m, :boundarynodes))
```

A group behaves like a vector of integer values.

```{julia}
g = group(m, :boundarynodes)
g[17:23]
```

Groups can be used to filter access to coordinates.

```{julia}
m = Mesh(meshpath("complex-g1.msh"))
p = mplot(m) |> mconf()
scatter!(coordinates(m, group(m, :boundarynodes)), color=:hotpink)
p
```

Additional groups are defined by specifying a dimension, a name and indices.

```{julia}
definegroup!(m, 2, :f1, 100:300)
definegroup!(m, 2, :f2, 200:600)
definegroup!(m, 1, :e1, 600:800)
definegroup!(m, 1, :e2, 700:900)
mplot(m) |> mconf()
```

## Information associated with Entities: Data

Example how to attach data to mesh entities:

```{julia}
m = Mesh(meshpath("complex-g1.msh"))

n1 = node(m, 1)
n2 = node(m, 2)
e22 = element(m, 22)

setdata!(n1, :d1, 42)
setdata!(e22, :d2, 61)

println("data( n1, :d1) = ", data(n1, :d1))
println("data( n2, :d1) = ", data(n2, :d1))
println("data(e22, :d2) = ", data(e22, :d2))
```

Use `hasdata` to test, if data is defined:

```{julia}
println("hasdata( n1, :d1) = ", hasdata(n1, :d1))
println("hasdata( n2, :d1) = ", hasdata(n2, :d1))
```

Example how to attach data to groups:

```{julia}
m = Mesh(meshpath("complex-g1.msh"))

g1 = group(m, :s1)
g2 = group(m, :s2)
g3 = group(m, :s3)

println("s1: ", g1)
println("s2: ", g2)
println("s3: ", g3)

setdata!(g1, :foo, "f1")
setdata!(g2, :foo, "f2")
setdata!(g3, :foo, "f3")

e2 = element(m, 5)
e490 = element(m, 490)
e1132 = element(m, 1132)

println("data(e2, :foo) = ", data(e2, :foo))
println("data(e490, :foo) = ", data(e490, :foo))
println("data(e1132, :foo) = ", data(e1132, :foo))
```

Example how to attach data to elements:

```{julia}
m = Mesh(0 .. 10, 20)
setdata!(group(m, :elements), :foo, 99)
println(data(element(m, 2), :foo))
```

Set data for nodes and access it on an element level

```{julia}
using Statistics # For mean - function

m = Mesh(:quadtri)
setdata!(m, :a, 100 * (1:nnodes(m)))
println("   Value for node 3: ", data(node(m, 3), :a))
println(" Nodes of element 1: ", nodeindices(element(m, 1)))
println("Values of element 1: ", data(element(m, 1), :a))
println(" Mean for element 1: ", mean(data(element(m, 1), :a)))
```

