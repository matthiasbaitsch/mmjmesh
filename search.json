[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The MMJMesh Library",
    "section": "",
    "text": "1 Introduction\nThe MMJMesh library is intended to become a simple yet versatile basis for the implementation of finite element methods or postprocessing tools. At the moment it is in a very early stage of development."
  },
  {
    "objectID": "index.html#demo-for-1d-meshes",
    "href": "index.html#demo-for-1d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.1 Demo for 1D meshes",
    "text": "1.1 Demo for 1D meshes\nFirst, we need to load the required modules. Note that CairoMakie included by import and not by using in order to avoid name collissions.\n\nimport CairoMakie\nusing MMJMesh.Plots\nusing MMJMesh.Meshes\nusing MMJMesh.Utilities\n\nIn the simplest case, a 1D mesh is defined by parameter bounds and the number of elements.\n\nm = makemeshoninterval(0.0, 8.0, 4)\nmplot(m) |&gt; mconf()\n\n\n\n\nElements of the mesh can be easily processed in a loop:\n\nfor e ∈ elements(m)\n    println(e, \" with n = \", nodeIdxs(e), \" and l = \", length(e))\nend\n\nEdge[1] with n = [1, 2] and l = 2.0\nEdge[2] with n = [2, 3] and l = 2.0\nEdge[3] with n = [3, 4] and l = 2.0\nEdge[4] with n = [4, 5] and l = 2.0\n\n\nVarious functions like nodeIdxs and length exist to access properties. If you are used to an object-oriented language like Java it might be helpful to understand that nodeIdxs(e) in Julia is equivalent to e.nodeIdxs() in an OO language.\nNode coordinates are retrieved using the coordinates method:\n\ncoordinates(m)\n\n2×5 Matrix{Float64}:\n 0.0  2.0  4.0  6.0  8.0\n 0.0  0.0  0.0  0.0  0.0\n\n\nProperties are associated with the mesh using the data field of the mesh and a name for the property in the form :name\n\nm.data[:foo] = 99\nm.data[:bar] = sqrt;\n\nand then are ready to be used in a later stage\n\nf = m.data[:bar]\nf(4)\n\n2.0\n\n\nIn Julia, :name is called a symbol. In many applications, this is equivalent to the use of strings like \"name\", however, easier to type.\nIt is easy to plot quantities for nodes\n\nmplot(m, -1 .+ 2 * rand(nnodes(m))) |&gt; mconf()\n\n\n\n\nconstant on elements\n\nmplot(m, -1 .+ 2 * rand(nelements(m))) |&gt; mconf()\n\n\n\n\nor linear on elements\n\nmplot(m, -1 .+ 2 * rand(2, nelements(m))) |&gt; mconf()\n\n\n\n\nFurthermore, 1D meshes can be created with a parametric function\n\nm = makemeshoninterval(0, 5, 60, t -&gt; [t; 0.3 * sin(π * t)])\nmplot(m) |&gt; mconf()\n\n\n\n\nwhere the last parameter t -&gt; [t; sin(t)] (read: t is mapped on the vector (t, sin(t))) defines the parametric curve\n\\[\n    \\mathbf{u}(t) =\n    \\left(\n    \\begin{array}{c}\n        t\n        \\\\\n        \\sin(t)\n    \\end{array}\n    \\right).\n\\]"
  },
  {
    "objectID": "index.html#demo-for-2d-meshes",
    "href": "index.html#demo-for-2d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.2 Demo for 2D meshes",
    "text": "1.2 Demo for 2D meshes\nCreate mesh on rectangular grid\n\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nmplot(m) |&gt; mconf()\n\n\n\n\nRead mesh from Gmsh\n\nm = Mesh(\"../data/gmsh/advanced.msh\")\nmplot(m) |&gt; mconf()\n\n\n\n\nIndexes of nodes on boundary\n\nm.groups[:boundarynodes]\n\n12-element MMJMesh.Groups.EntityGroup{0}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  9\n 10\n 11\n 12\n 13"
  },
  {
    "objectID": "mesh.html#basic-usage",
    "href": "mesh.html#basic-usage",
    "title": "2  The Mesh interface",
    "section": "2.1 Basic usage",
    "text": "2.1 Basic usage\nCreate mesh\n\ncoords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]\nelts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]\nm = Mesh(coords, elts, 2)\nmplot(m) |&gt; mconf()\n\n\n\n\nCoordinates of a node\n\ncoordinates(node(m, 2))\n\n2-element Vector{Float64}:\n 1.0\n 0.1\n\n\nCoordinates of a face\n\ncoordinates(face(m, 3))\n\n2×3 Matrix{Float64}:\n 1.0  1.9  0.9\n 0.1  0.9  1.0\n\n\nProcess faces and print node and edge indexes\n\nfor e ∈ elements(m)\n    println(e)\n    println(\"- \", nodeIdxs(e))\n    println(\"- \", edgeIdxs(e))\n    println(\"- \", faceIdxs(e))\nend\n\nFace[1]\n- \n\n\n[1, 2, 5, 4]\n- [1, 2, 3, 4]\n- [3]\nFace[2]\n- [2, 3, 6]\n- [5, 6, 7]\n- [3]\nFace[3]\n- [2, 6, 5]\n- [7, 8, 2]\n- [1, 2]"
  },
  {
    "objectID": "mesh.html#read-mesh-from-gmsh-file",
    "href": "mesh.html#read-mesh-from-gmsh-file",
    "title": "2  The Mesh interface",
    "section": "2.2 Read mesh from Gmsh file",
    "text": "2.2 Read mesh from Gmsh file\n\nm = Mesh(\"../data/gmsh/complex-g1.msh\")\nmplot(m, edgesvisible=true) |&gt; mconf()"
  },
  {
    "objectID": "plot.html#plot-a-1d-mesh",
    "href": "plot.html#plot-a-1d-mesh",
    "title": "3  Plotting",
    "section": "3.1 Plot a 1D mesh",
    "text": "3.1 Plot a 1D mesh\n\n3.1.1 On a straight line\n\nm = makemeshoninterval(0, 4, 20) \nmplot(m) |&gt; mconf()\n\n\n\n\nNodes hidden if too many.\n\nm = makemeshoninterval(0, 4, 60)\nmplot(m) |&gt; mconf()\n\n\n\n\nOne value per node\n\nmplot(m, -1.1 .+ 2.6 * rand(nnodes(m))) |&gt; mconf()\n\n\n\n\nOne value per element\n\nmplot(m, -1.1 .+ 2.2 * rand(nedges(m))) |&gt; mconf()\n\n\n\n\nTwo values per element\n\nmplot(m, -1.1 .+ 2.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n3.1.2 Vertical\n\nm = makemeshoninterval(π, 3π, 20, t -&gt; [0; t])\nmplot(m, -1.1 .+ 3.2 * rand(nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n3.1.3 On a spiral\n\nm = makemeshoninterval(π, 3π, 20, t -&gt; t * [cos(t); sin(t)])\nmplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n3.1.4 Customize plot\nPlot customization works like this:\n\nf, ax = mplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\nax.title = \"Spiral with reversed vertical axis\"\nax.yreversed = true\nf\n\n\n\n\nDocumentation on plot axis can be found on the Makie documentation which unfortunately is quite hard to read."
  },
  {
    "objectID": "plot.html#plot-a-2d-mesh",
    "href": "plot.html#plot-a-2d-mesh",
    "title": "3  Plotting",
    "section": "3.2 Plot a 2D mesh",
    "text": "3.2 Plot a 2D mesh\n\n3.2.1 Quad mesh\n\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nprintln(\"Number of nodes is Nn = \", (a + 1) * (2a + 1))\nprint(\"Links...\")\n@time l12 = links(m.topology, 1, 2);\n\nNumber of nodes is Nn = 13041\nLinks...  0.002217 seconds (17 allocations: 928 bytes, 99.32% compilation time)\n\n\nDefault color\n\nmplot(m, edgesvisible=true, edgecolor=:hotpink) |&gt; mconf()\n\n\n\n\nColors for nodes\n\nmplot(m, 4.1 * (rand(nnodes(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\nColors for elements\n\nmplot(m, 4.1 * (rand(nfaces(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\n\n\n3.2.2 Triangle mesh\n\na = 20\nm = makemeshonrectangle(9.0, 4.5, 2a, a, TRIANGLE)\nprintln(\"Nn = \", (a + 1) * (2a + 1))\nprint(\"Links (1, 2):\")\n@time l12 = links(m.topology, 1, 2);\n\nNn = 861\nLinks (1, 2):  0.000006 seconds (3 allocations: 112 bytes)\n\n\nDefault color\n\nmplot(m, edgesvisible=true) |&gt; mconf()\n\n\n\n\nColors for nodes\n\nmplot(m, 4.1 * (rand(nnodes(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\nColors for elements\n\nmplot(m, 4.1 * (rand(nfaces(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\n\ncm.set_theme!(cm.theme_minimal())\nm = makemeshoninterval(π, 3π, 20, t -&gt; t * [cos(t); sin(t)])\n# cm.with_theme(cm.theme_dark()) do\n# cm.update_theme!(xxx=:blue)\n# cm.update_theme!(markercolor=:tomato)\ncm.update_theme!(Axis=(leftspinevisible=false,))\n\n#println(cm.theme(:markercolor)[])\n\nmplot(m, edgecolor = :green)\n#cm.scatter(coordinates(m))\n#end"
  },
  {
    "objectID": "plot.html#plot-options",
    "href": "plot.html#plot-options",
    "title": "3  Plotting",
    "section": "3.3 Plot options",
    "text": "3.3 Plot options\n\na = 10\nm1 = makemeshonrectangle(4, 2, 2a, a)\nmplot(m1, 3 * rand(nfaces(m1)),\n    nodesvisible=true, nodecolor=:hotpink, nodesize=12,\n    edgesvisible=true, edgecolor=:lightblue, edgelinewidth=3,\n    featureedgecolor=:red, featureedgelinewidth=6,\n    facecolormap=:bluesreds\n) |&gt; mconf()\n\n\n\n\n\nm2 = makemeshoninterval(0, 4, 20)\nmplot(m2, rand(nnodes(m2)),\n    lineplotoutlinesvisible=true,\n    edgecolor=:blue, edgelinewidth=10,\n    lineplotscale=0.3,\n    lineplotoutlinescolor=:hotpink,\n    lineplotoutlineslinewidth=2.0,\n    lineplotfacescolormap=:bluesreds\n) |&gt; mconf(title=\"Test Plot\")"
  },
  {
    "objectID": "plot.html#adaptive-sampling",
    "href": "plot.html#adaptive-sampling",
    "title": "3  Plotting",
    "section": "3.4 Adaptive sampling",
    "text": "3.4 Adaptive sampling\n\n3.4.1 Derivation of quadrature formulae\n\nX1 = 0:1/4:1\nL1 = lagrangepolynomials(X1, 0 .. 1)\nW1 = [integrate(L, 0 .. 1) for L in L1]\n\nX2 = [0, 0.253124, 0.4986745, 0.75834, 1]\nL2 = lagrangepolynomials(X2, 0 .. 1)\nW2 = [integrate(L, 0 .. 1) for L in L2]\n\nfunction nint(f, a, b)\n    w = b - a\n    y1 = f.(a .+ w * X1)\n    y2 = f.(a .+ w * X2)\n    w * dot(W1, y1), w * dot(W2, y2)\nend\n\nprintln(nint(x -&gt; x, 0, 2))\nprintln(nint(sin, 0, pi))\nprintln(nint(sin, pi, 2pi))\n\n(1.999999999999996, 1.999999999999985)\n(1.9985707318238337, 1.9986169017000417)\n(-1.9985707318238337, -1.998616901700041)\n\n\n\n\n3.4.2 Integral of squared distance between curve and straight line\n\n\nCode\nfunction doplot(xy)\n    x, y = xy\n    f = cm.lines(x, y)\n    cm.scatter!(x, y, color=:darkred, markersize=5)\n    return f\nend\n\nfunction convergence(f, a, b, n)\n    h = 1\n    X = X2\n    W = W2\n    e = zeros(n)\n\n    for i in 1:n\n        w = b - a\n        x = a .+ w * X\n        y = f.(x)\n        e[i] = approximationerror(h, X, W, y)\n        b = (a + b) / 2\n        h /= 2\n    end\n\n    return e\nend\n\n\nconvergence (generic function with 1 method)\n\n\n\nn = 5\n(1:n, convergence(x -&gt; 100x^3, -0.25, 1.5, n)) |&gt; doplot\n\n\n\n\n\n(1:n, convergence(sin, 0, pi, n)) |&gt; doplot\n\n\n\n\n\n(1:n, convergence(x -&gt; 1 / x, -1, 1e-5, n)) |&gt; doplot\n\n\n\n\n\nn = 20\n(1:n, convergence(x -&gt; sin(1 / x), 1e-5, 1e-1, n)) |&gt; doplot\n\n\n\n\n\n\n3.4.3 Test cases\n\nsampleadaptive(x -&gt; x^100, 0, 1) |&gt; doplot\n\n\n\n\n\nsampleadaptive(x -&gt; sin(1.0 / x), 0, 0.05, level=14) |&gt; doplot\n\n\n\n\n\nsampleadaptive(x -&gt; 1 / x, -1, 1) |&gt; doplot\n\n\n\n\n\nsampleadaptive(x -&gt; (-0.3 + x), -1, 1, ir=true) |&gt; doplot\n\n\n\n\n\nsampleadaptive(x -&gt; x^2, -1, 1) |&gt; doplot"
  },
  {
    "objectID": "mathematics.html#mappings",
    "href": "mathematics.html#mappings",
    "title": "4  Mathematics",
    "section": "4.1 Mappings",
    "text": "4.1 Mappings\n\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nplot(c, s, g, p)\n\n\n\n\n\nf = Polynomial([0, 1], -1 .. 1)\nF = antiderivative(f)\nplot(f, F)\n\n\n\n\n\nintegrate(f, 0 .. 1)\n\n0.5\n\n\n\np = [0, 1, 2]\nf = plot(fromroots(p, -0.1 .. 2.1))\nCairoMakie.scatter!(p, 0 * p, color=:tomato)\nf\n\n\n\n\n\np = [0, 1.5, 2]\nf = plot(lagrangepolynomials(p, 0 .. 2)...)\nCairoMakie.scatter!(p, 0 * p, color=:tomato)\nCairoMakie.scatter!(p, 1 .+ 0 * p, color=:blue)\nf\n\n\n\n\n\n4.1.1 Monomials\n\nplot(monomials(0:100, 0 .. 1)...)\n\n\n\n\n\n\n4.1.2 Hermite like polynomials with middle node\nDefine linear forms\n\nstruct ValueAt &lt;: AbstractMapping{AbstractMapping,Real,Everything()}\n    x::Real\nend\nMMJMesh.Mathematics.valueat(u::ValueAt, f) = f(u.x)\n\nstruct DerivativeAt &lt;: AbstractMapping{AbstractMapping,Real,Everything()}\n    x::Real\nend\nMMJMesh.Mathematics.valueat(u::DerivativeAt, f) = f'(u.x)\n\nCompute polynomials from Vandermonde matrix\n\nh = 2.0\nN = [ValueAt.(0:h/2:h); DerivativeAt.([0, h])] |&gt; vcat\nP = monomials(0:length(N)-1, 0 .. h)\nM = [n(p) for p in P, n in N]\nH = inv(M) * P\nplot(H...)"
  }
]