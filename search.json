[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The MMJMesh Library",
    "section": "",
    "text": "1 Introduction\nThe MMJMesh library is intended to become a simple yet versatile basis for the implementation of finite element methods or postprocessing tools. At the moment it is in a very early stage of development.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#demo-for-1d-meshes",
    "href": "index.html#demo-for-1d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.1 Demo for 1D meshes",
    "text": "1.1 Demo for 1D meshes\nFirst, we need to load the required modules. Note that CairoMakie included by import and not by using in order to avoid name collissions.\n\nimport CairoMakie\nusing IntervalSets\nusing MMJMesh.Plots\nusing MMJMesh.Meshes\nusing MMJMesh.Utilities\nusing MMJMesh.Mathematics\n\nIn the simplest case, a 1D mesh is defined by parameter bounds and the number of elements.\n\nm = makemeshoninterval(0.0, 8.0, 4)\nmplot(m) |&gt; mconf()\n\n\n\n\n\n\n\n\nElements of the mesh can be easily processed in a loop:\n\nfor e ∈ elements(m)\n    println(e, \" with n = \", nodeindices(e), \" and l = \", length(e))\nend\n\nEdge{2, 2}[1] with n = [1, 2] and l = 2.0\nEdge{2, 2}[2] with n = [2, 3] and l = 2.0\nEdge{2, 2}[3] with n = [3, 4] and l = 2.0\nEdge{2, 2}[4] with n = [4, 5] and l = 2.0\n\n\nVarious functions like nodeindices and length exist to access properties. If you are used to an object-oriented language like Java it might be helpful to understand that nodeindices(e) in Julia is equivalent to e.nodeindices() in an OO language.\nNode coordinates are retrieved using the coordinates method:\n\ncoordinates(m)\n\n2×5 Matrix{Float64}:\n 0.0  2.0  4.0  6.0  8.0\n 0.0  0.0  0.0  0.0  0.0\n\n\nProperties are associated with the mesh using the data field of the mesh and a name for the property in the form :name\n\nm.data[:foo] = 99\nm.data[:bar] = sqrt;\n\nand then are ready to be used in a later stage\n\nf = m.data[:bar]\nf(4)\n\n2.0\n\n\nIn Julia, :name is called a symbol. In many applications, this is equivalent to the use of strings like \"name\", however, easier to type.\nIt is easy to plot quantities for nodes\n\nmplot(m, -1 .+ 2 * rand(nnodes(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\nconstant on elements\n\nmplot(m, -1 .+ 2 * rand(nelements(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\nlinear on elements\n\nmplot(m, -1 .+ 2 * rand(2, nelements(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\nfunctions on elements\n\nmplot(m, [Polynomial(rand(-1 .. 1, 4), IHat) for _ ∈ 1:nelements(m)]) |&gt; mconf()\n\n\n\n\n\n\n\n\nFurthermore, 1D meshes can be created with a parametric function\n\nm = makemeshoninterval(0, 5, 60, t -&gt; [t; 0.3 * sin(π * t)])\nmplot(m) |&gt; mconf()\n\n\n\n\n\n\n\n\nwhere the last parameter t -&gt; [t; sin(t)] (read: t is mapped on the vector (t, sin(t))) defines the parametric curve\n\\[\n    \\mathbf{u}(t) =\n    \\left(\n    \\begin{array}{c}\n        t\n        \\\\\n        \\sin(t)\n    \\end{array}\n    \\right).\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#demo-for-2d-meshes",
    "href": "index.html#demo-for-2d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.2 Demo for 2D meshes",
    "text": "1.2 Demo for 2D meshes\nCreate mesh on rectangular grid\n\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nmplot(m) |&gt; mconf()\n\n\n\n\n\n\n\n\nRead mesh from Gmsh\n\nm = Mesh(\"../data/gmsh/advanced.msh\")\nmplot(m) |&gt; mconf()\n\n\n\n\n\n\n\n\nIndices of nodes on boundary\n\nm.groups[:boundarynodes]\n\n12-element NodeGroup:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  9\n 10\n 11\n 12\n 13",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "mesh.html",
    "href": "mesh.html",
    "title": "2  The Mesh interface",
    "section": "",
    "text": "2.1 Basic usage\nCreate mesh\ncoords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]\nelts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]\nm = Mesh(coords, elts, 2)\nmplot(m) |&gt; mconf()\nCoordinates of a node\ncoordinates(node(m, 2))\n\n2-element Vector{Float64}:\n 1.0\n 0.1\nCoordinates of a face\ncoordinates(face(m, 3))\n\n2×3 Matrix{Float64}:\n 1.0  1.9  0.9\n 0.1  0.9  1.0\nProcess faces and print node and edge indices\nfor e ∈ elements(m)\n    println(e)\n    println(\"- \", nodeindices(e))\n    println(\"- \", edgeindices(e))\n    println(\"- \", faceindices(e))\nend\n\nFace{2, 4}[1]\n- [1, 2, 5, 4]\n- [1, 2, 3, 4]\n- [3]\nFace{2, 3}[2]\n- [2, 3, 6]\n- [5, 6, 7]\n- [3]\nFace{2, 3}[3]\n- [2, 6, 5]\n- [7, 8, 2]\n- [1, 2]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "mesh.html#read-mesh-from-gmsh-file",
    "href": "mesh.html#read-mesh-from-gmsh-file",
    "title": "2  The Mesh interface",
    "section": "2.2 Read mesh from Gmsh file",
    "text": "2.2 Read mesh from Gmsh file\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\nmplot(m, edgesvisible=true) |&gt; mconf()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "mesh.html#groups-and-predefined-groups",
    "href": "mesh.html#groups-and-predefined-groups",
    "title": "2  The Mesh interface",
    "section": "2.3 Groups and predefined groups",
    "text": "2.3 Groups and predefined groups\nMesh entities can be collected in groups some of which are predefined.\n\nkeys(m.groups.recipes)\n\nKeySet for a Dict{Symbol, Function} with 7 entries. Keys:\n  :solids\n  :boundaryfaces\n  :faces\n  :nodes\n  :edges\n  :boundaryedges\n  :boundarynodes\n\n\n\nshow(m.groups[:boundarynodes])\n\nNodeGroup[1:19, 31:34, 46:106, 116:157]\n\n\nGroups can be used to filter access\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\np = mplot(m)\ncm.scatter!(p.axis, coordinates(m, :boundarynodes), color = :hotpink)\np |&gt; mconf()\n\n\n\n\n\n\n\n\nAdditional groups can be defined\n\nm.groups[:f1] = FaceGroup(100:300)\nm.groups[:f2] = FaceGroup(200:600)\nm.groups[:e1] = EdgeGroup(600:800)\nm.groups[:e2] = EdgeGroup(700:900)\nmplot(m) |&gt; mconf()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "mesh.html#data",
    "href": "mesh.html#data",
    "title": "2  The Mesh interface",
    "section": "2.4 Data",
    "text": "2.4 Data\nExample how to attach data to mesh entities:\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\n\nn1 = node(m, 1)\nn2 = node(m, 2)\ne22 = element(m, 22)\nn1.data[:d1] = 42\ne22.data[:d2] = 61\n\nprintln(\" n1.data[:d1] = \", n1.data[:d1])\nprintln(\" n2.data[:d1] = \", n2.data[:d1])\nprintln(\"e22.data[:d2] = \", e22.data[:d2])\n\n n1.data[:d1] = 42\n n2.data[:d1] = nothing\ne22.data[:d2] = 61\n\n\nExample how to attach data to groups:\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\n\nprintln(\"s1: \", m.groups[:s1].indices)\nprintln(\"s2: \", m.groups[:s2].indices)\nprintln(\"s3: \", m.groups[:s3].indices)\n\nm.data[:kefunc, :s1] = \"f1\";\nm.data[:kefunc, :s2] = \"f2\";\nm.data[:kefunc, :s3] = \"f3\";\n\ne0005 = element(m, 0005)\ne0490 = element(m, 0490)\ne1132 = element(m, 1132)\n\nprintln(\"e0005.data[:kefunc] = \", e0005.data[:kefunc])\nprintln(\"e0490.data[:kefunc] = \", e0490.data[:kefunc])\nprintln(\"e1132.data[:kefunc] = \", e1132.data[:kefunc])\n\ns1: [1:488]\ns2: [489:1130]\ns3: [1131:1372]\ne0005.data[:kefunc] = f1\ne0490.data[:kefunc] = f2\ne1132.data[:kefunc] = f3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "3  Plotting",
    "section": "",
    "text": "3.1 Plot a 1D mesh",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "plot.html#plot-a-1d-mesh",
    "href": "plot.html#plot-a-1d-mesh",
    "title": "3  Plotting",
    "section": "",
    "text": "3.1.1 On a straight line\n\nm = makemeshoninterval(0, 4, 20)\nmplot(m) |&gt; mconf()\n\n\n\n\n\n\n\n\nNodes hidden if too many.\n\nm = makemeshoninterval(0, 4, 60)\nmplot(m) |&gt; mconf()\n\n\n\n\n\n\n\n\nOne value per node\n\nmplot(m, -1.1 .+ 2.6 * rand(nnodes(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\nOne value per element\n\nmplot(m, -1.1 .+ 2.2 * rand(nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\nTwo values per element\n\nmplot(m, -1.1 .+ 2.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\n\n\n3.1.2 Vertical\n\nm = makemeshoninterval(π, 3π, 20, t -&gt; [0; t])\nmplot(m, -1.1 .+ 3.2 * rand(nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\n\n\n3.1.3 On a spiral\n\nm = makemeshoninterval(π, 3π, 20, t -&gt; t * [cos(t); sin(t)])\nmplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n\n\n\n\n3.1.4 Customize plot\nPlot customization works like this:\n\nf, ax = mplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\nax.title = \"Spiral with reversed vertical axis\"\nax.yreversed = true\nf\n\n\n\n\n\n\n\n\nDocumentation on plot axis can be found on the Makie documentation which unfortunately is quite hard to read.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "plot.html#plot-a-2d-mesh",
    "href": "plot.html#plot-a-2d-mesh",
    "title": "3  Plotting",
    "section": "3.2 Plot a 2D mesh",
    "text": "3.2 Plot a 2D mesh\n\n3.2.1 Quad mesh\n\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nprintln(\"Number of nodes is Nn = \", (a + 1) * (2a + 1))\nprint(\"Links...\")\n@time l12 = links(m.topology, 1, 2);\n\nNumber of nodes is Nn = 13041\nLinks...  0.091282 seconds (1.11 M allocations: 86.504 MiB, 32.34% gc time, 14.82% compilation time)\n\n\nDefault color\n\nmplot(m, edgesvisible=true, edgecolor=:hotpink) |&gt; mconf()\n\n\n\n\n\n\n\n\nColors for nodes\n\nmplot(m, 4.1 * (rand(nnodes(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\n\n\n\n\nColors for elements\n\nmplot(m, 4.1 * (rand(nfaces(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\n\n\n\n\n\n\n3.2.2 Triangle mesh\n\na = 20\nm = makemeshonrectangle(9.0, 4.5, 2a, a, TRIANGLE)\nprintln(\"Nn = \", (a + 1) * (2a + 1))\nprint(\"Links (1, 2):\")\n@time l12 = links(m.topology, 1, 2);\n\nNn = 861\nLinks (1, 2):  0.004371 seconds (101.71 k allocations: 8.229 MiB)\n\n\nDefault color\n\nmplot(m, edgesvisible=true) |&gt; mconf()\n\n\n\n\n\n\n\n\nColors for nodes\n\nmplot(m, 4.1 * (rand(nnodes(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\n\n\n\n\nColors for elements\n\nmplot(m, 4.1 * (rand(nfaces(m)) .- 0.25)) |&gt; mconf()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "plot.html#plot-options",
    "href": "plot.html#plot-options",
    "title": "3  Plotting",
    "section": "3.3 Plot options",
    "text": "3.3 Plot options\n\na = 10\nm1 = makemeshonrectangle(4, 2, 2a, a)\nmplot(m1, 3 * rand(nfaces(m1)),\n    nodesvisible=true, nodecolor=:hotpink, nodesize=12,\n    edgesvisible=true, edgecolor=:lightblue, edgelinewidth=3,\n    featureedgecolor=:red, featureedgelinewidth=6,\n    facecolormap=:bluesreds\n) |&gt; mconf()\n\n\n\n\n\n\n\n\n\nm2 = makemeshoninterval(0, 4, 20)\nmplot(m2, rand(nnodes(m2)),\n    lineplotoutlinesvisible=true,\n    edgecolor=:blue, edgelinewidth=10,\n    lineplotscale=0.3,\n    lineplotoutlinescolor=:hotpink,\n    lineplotoutlineslinewidth=2.0,\n    lineplotfacescolormap=:bluesreds\n) |&gt; mconf(title=\"Test Plot\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "mathematics.html",
    "href": "mathematics.html",
    "title": "4  Mathematics",
    "section": "",
    "text": "4.1 Mappings",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mathematics</span>"
    ]
  },
  {
    "objectID": "mathematics.html#mappings",
    "href": "mathematics.html#mappings",
    "title": "4  Mathematics",
    "section": "",
    "text": "4.1.1 Functions \\(\\mathbb{R} \\to \\mathbb{R}\\)\n\nf = Sin() ∘ (1 / Polynomial(0, 1, d=0.0 .. 0.05))\nfplot(f, yscale=0.05, npoints=11)\n\n\n\n\n\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nfplot(c, s, g, p)\n\n\n\n\n\nf = Polynomial([0, 1], -1 .. 1)\nF = antiderivative(f)\nfplot(f, F)\n\n\n\n\n\nintegrate(f, 0 .. 1)\n\n0.5\n\n\n\np = [0, 1, 2]\nf = fplot(fromroots(p, -0.1 .. 2.1))\ncm.scatter!(p, 0 * p, color=:tomato)\nf\n\n\n\n\n\np = [0, 1.5, 2]\nf = fplot(lagrangepolynomials(p, 0 .. 2)...)\ncm.scatter!(p, [0, 0, 0], color=:tomato)\ncm.scatter!(p, [1, 1, 1], color=:blue)\nf\n\n\n\n\n\n\n4.1.2 Parametric curves\nLissajous curve\n\nu = ParametricCurve(Cos(0 .. 2π), Sin() ∘ Polynomial(0, 2, d=0 .. 2pi))\nv = 0.075 * Sin() ∘ Polynomial(0, 100) * UnitNormal(u)\nw = 0.025 * ParametricCurve(Sin(), Cos()) ∘ Polynomial(0, 200)\nfplot(u, u + v, u + w)\n\n\n\n\n\npts = tomatrix([[0.0, 0], [1.5, 1], [2, 0], [1.5, -1], [0, 0]])\nfig, ax = fplot(Interpolation(pts, 1))\ncm.scatter!(ax, pts, color=:tomato)\nfig\n\n\n\n\n\n\n4.1.3 Monomials\n\nfplot(monomials(0:100, 0 .. 1)...)\n\n\n\n\n\n\n4.1.4 Functions of two variables\nCreate the function \\(f : [0, 5\\pi]^2 \\to \\mathbb{R}, \\quad f(\\mathbf{x}) = \\sin x_1 \\sin x_2\\)\n\nf = makefunction(x -&gt; exp(-hypot(x[1], x[2])^2 / 20) * cos(x[1]) * cos(x[2]), -2π .. 2π, -2π .. 2π);\n\nBy default the plot is a view down from positive \\(z\\) direction\n\nfplot3d(f, mesh=9)\n\n\n\n\nCreate a 3D plot using Axis3 and switch of the mesh off since CairoMakie does not handle hidden lines.\n\nfig = Figure()\nAxis3(fig[1, 1])\nfplot3d!(f, npoints=250, mesh=nothing)\nfig\n\n\n\n\nA (sometimes?) interactive 3D plot is obtained using WebGL:\n\nWGLMakie.activate!()\nfig = Figure()\nAxis3(fig[1, 1])\nfplot3d!(f, mesh=19, npoints=250)\nfig\n\n\n  \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n  \n  \n    \n      \n      \n        \n      \n    \n    \n      \n      \n        \n      \n    \n  \n\n\n\nMultivariate polynomial \\(f(x, y) = x^2 y - y\\)\n\ng = MPolynomial([2 1; 0 1], [1.0, -1.0], QHat)\nfig = Figure()\nAxis3(fig[1, 1])\nfplot3d!(g)\nfig\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\nMultivariate monomials\n\nfplot3d(mmonomials(2, 3, QHat))\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\nPlot gradient of product function\n\nCairoMakie.activate!()\ng = ProductFunction(Sin(0 .. 2π), Sin(0 .. 2π))\nfig = Figure()\nAxis(fig[1, 1])\nfplot3d!(g, mesh=nothing)\nvplot!(gradient(g), npoints=9, lengthscale=0.3)\nfig",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mathematics</span>"
    ]
  },
  {
    "objectID": "sampling.html",
    "href": "sampling.html",
    "title": "5  Adaptive sampling",
    "section": "",
    "text": "Plot function\n\nfunction doplot(xy)\n    f = cm.lines(xy)\n    cm.scatter!(xy, color=:darkred, markersize=5)\n    return f\nend;\n\nLinear function\n\nsample1d(x -&gt; x, -1, 1) |&gt; doplot\n\n\n\n\n\n\n\n\nParabola\n\nsample1d(x -&gt; x^2, -1, 1) |&gt; doplot\n\n\n\n\n\n\n\n\nCurved in one region\n\nsample1d(x -&gt; x^100, 0, 1) |&gt; doplot\n\n\n\n\n\n\n\n\nSingular point\n\nsample1d(x -&gt; sin(1.0 / x), 0.0, 0.05, maxangle=0.05, npoints=21) |&gt; doplot\n\n\n\n\n\n\n\n\n\nsample1d(x -&gt; sin(1.0 / x), 0.0, 0.05, yscale=0.05, npoints=21) |&gt; doplot\n\n\n\n\n\n\n\n\n\n@time size(sample1d(x -&gt; sin(1.0 / x), 0.0, 0.05, maxangle=0.1), 2)\n\n  0.043987 seconds (353.86 k allocations: 7.730 MiB, 18.48% compilation time)\n\n\n8479\n\n\nMultiple curvatures\n\nsample1d(x -&gt; sin(30 * sin(x)), 0, 2pi) |&gt; doplot\n\n\n\n\n\n\n\n\nDiscontinuity\n\nsample1d(x -&gt; 1 / x, 0, 1, yscale=1e-5) |&gt; doplot\n\n\n\n\n\n\n\n\nInsert root\n\nsample1d(x -&gt; (-0.3 + x), -1, 1, ir=true) |&gt; doplot\n\n\n\n\n\n\n\n\nNon smooth function\n\nsample1d(x -&gt; abs(x), -1, 1) |&gt; doplot\n\n\n\n\n\n\n\n\nLocal peak\n\na = 0.01\nf = Polynomial(0, 1, d=-1 .. 1) + a^2 / Polynomial(a^2, 0.0, 1.0)\nsample1d(f, -1, 1) |&gt; doplot\n\n\n\n\n\n\n\n\nCircle\n\nu = ParametricCurve(Cos(0 .. 2π), Sin(0 .. 2π))\nsample1d(u, 0, 2pi) |&gt; doplot",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adaptive sampling</span>"
    ]
  },
  {
    "objectID": "finite-elements.html",
    "href": "finite-elements.html",
    "title": "6  Shape functions and finite elements",
    "section": "",
    "text": "6.1 Shape functions\nLinear shape functions\nN = [ValueAtLF(-1), ValueAtLF(1)]\nP = monomials(0:1, -1 .. 1)\nM = [n(p) for p ∈ P, n ∈ N]\nL11 = inv(M) * P\n\nfplot(L11...)\nHermite polynomials\nh = 2.0\nN = [ValueAtLF(-1), DerivativeAtLF(-1), ValueAtLF(1), DerivativeAtLF(1)]\nP = monomials(0:length(N)-1, IHat)\nM = [n(p) for p in P, n in N]\nH1 = inv(M) * P\nfplot(H1...)\nHermite like polynomials with middle node\nh = 2.0\nN = [ValueAtLF.(0:h/2:h); DerivativeAtLF.([0, h])] |&gt; vcat\nP = monomials(0:length(N)-1, 0 .. h)\nM = [n(p) for p in P, n in N]\nH = inv(M) * P\nfplot(H...)\nBilinear shape functions\nWGLMakie.activate!()\nV = [-1 1 1 -1; -1 -1 1 1]\nN = [ValueAtLF(p) for p in eachcol(V)]\nP = mmonomials(2, 1, QHat)\nM = [n(p) for p in P, n in N]\nL21 = inv(M) * P\nfplot3d(L21)\nSerendipity shape functions\nV = [-1 0 1 1 1 0 -1 -1; -1 -1 -1 0 1 1 1 0]\nP = mmonomials(2, 2, QHat, (p1, p2) -&gt; p1 + p2 &lt; 4)\nN = [ValueAtLF(p) for p in eachcol(V)]\nM = [n(p) for p in P, n in N]\nQ8 = inv(M) * P\nfplot3d(Q8)\nConforming rectangular plate element shape functions\nV = [-1 1 1 -1; -1 -1 1 1]\nP = mmonomials(2, 3, QHat)\nN = vcat(\n    [\n        [\n            ValueAtLF(p),\n            PDerivativeAtLF(p, [1, 0]),\n            PDerivativeAtLF(p, [0, 1]),\n            PDerivativeAtLF(p, [1, 1])\n        ]\n        for p in eachcol(V)\n    ]...\n)\nM = [n(p) for p in P, n in N]\nH4 = inv(M) * P\n\nfplot3d(H4)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shape functions and finite elements</span>"
    ]
  },
  {
    "objectID": "finite-elements.html#finite-element-stiffness-matrices",
    "href": "finite-elements.html#finite-element-stiffness-matrices",
    "title": "6  Shape functions and finite elements",
    "section": "6.2 Finite element stiffness matrices",
    "text": "6.2 Finite element stiffness matrices\n\n@variables l, a, b, EA, EI, ν;\n\n\n6.2.1 Truss\n\nD(u) = 2 / l * u'\nae(u, δu) = EA * l / 2 * integrate(D(u) * D(δu), IHat)\nKe = simplify.([ae(s1, s2) for s1 ∈ L11, s2 ∈ L11])\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cc}\n\\frac{EA}{l} & \\frac{ - EA}{l} \\\\\n\\frac{ - EA}{l} & \\frac{EA}{l} \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\n\n\n6.2.2 Beam\n\nH1l = [H1[1], l / 2 * H1[2], H1[3], l / 2 * H1[4]]\nD(w) = 4 / l^2 * w''\nae(w, δw) = EI * l / 2 * integrate(D(w) * D(δw), IHat)\nKe = simplify.(l^3 / EI * [ae(s1, s2) for s1 ∈ H1l, s2 ∈ H1l])\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cccc}\n12 & 6 l & -12 & 6 l \\\\\n6 l & 4 l^{2} &  - 6 l & 2 l^{2} \\\\\n-12 &  - 6 l & 12 &  - 6 l \\\\\n6 l & 2 l^{2} &  - 6 l & 4 l^{2} \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\n\n\n6.2.3 2D Poisson equation\nIntegration on the reference quadrilateral\n\nD(u) = [2 / a * ∂x(u), 2 / b * ∂y(u)]\nae(u, v) = a * b / 4 * integrate(D(u) ⋅ D(v), QHat)\nKe = simplify.(expand.(6 * a * b * [ae(n1, n2) for n1 ∈ L21, n2 ∈ L21]))\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cccc}\n2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} &  - a^{2} - b^{2} &  - 2 a^{2} + b^{2} \\\\\na^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) &  - 2 a^{2} + b^{2} &  - a^{2} - b^{2} \\\\\n- a^{2} - b^{2} &  - 2 a^{2} + b^{2} & 2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} \\\\\n- 2 a^{2} + b^{2} &  - a^{2} - b^{2} & a^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nAlternative derivation in physical coordinates\n\nV = [0 a a 0; 0 0 b b]\nN = [ValueAtLF(p) for p in eachcol(V)]\nP = mmonomials(2, 1, QHat)\nM = [n(p) for p in P, n in N]\nL21p = inv(M) * P\n\nae(u, v) = integrate(∇(u) ⋅ ∇(v), (0 .. a) × (0 .. b))\nKe = simplify.(expand.(6 * a * b * [ae(n1, n2) for n1 ∈ L21p, n2 ∈ L21p]))\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cccc}\n2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} &  - a^{2} - b^{2} &  - 2 a^{2} + b^{2} \\\\\na^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) &  - 2 a^{2} + b^{2} &  - a^{2} - b^{2} \\\\\n- a^{2} - b^{2} &  - 2 a^{2} + b^{2} & 2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} \\\\\n- 2 a^{2} + b^{2} &  - a^{2} - b^{2} & a^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nNicely formatted output. TODO: Handle LaTeX-String from latexify\n\\[\n    \\mathbf{K}^\\mathrm{e} = \\frac{1}{6ab} \\cdot L\"\\left[\n\\begin{array}{cccc}\n2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} &  - a^{2} - b^{2} &  - 2 a^{2} + b^{2} \\\\\na^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) &  - 2 a^{2} + b^{2} &  - a^{2} - b^{2} \\\\\n- a^{2} - b^{2} &  - 2 a^{2} + b^{2} & 2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} \\\\\n- 2 a^{2} + b^{2} &  - a^{2} - b^{2} & a^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) \\\\\n\\end{array}\n\\right]\"\n\\]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shape functions and finite elements</span>"
    ]
  }
]