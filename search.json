[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The MMJMesh Library",
    "section": "",
    "text": "1 Introduction\nThe MMJMesh library is intended to become a simple yet versatile basis for the implementation of finite element methods or postprocessing tools. At the moment it is in a very early stage of development.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#demo-for-1d-meshes",
    "href": "index.html#demo-for-1d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.1 Demo for 1D meshes",
    "text": "1.1 Demo for 1D meshes\nFirst, we need to load the required modules. Note that CairoMakie included by import and not by using in order to avoid name collissions.\n\ninclude(\"setup.jl\")\n\nmeshpath (generic function with 1 method)\n\n\nIn the simplest case, a 1D mesh is defined by parameter bounds and the number of elements.\n\nm = makemeshoninterval(0.0, 8.0, 4)\nmplot(m) |&gt; mconf()\n\n\n\n\nElements of the mesh can be easily processed in a loop:\n\nfor e ∈ elements(m)\n    println(e, \" with n = \", nodeindices(e), \" and l = \", length(e))\nend\n\nEdge{2, 2, MMJMesh.Geometries.GeometricObjectI}[1] with n = [1, 2] and l = 2.0\nEdge{2, 2, MMJMesh.Geometries.GeometricObjectI}[2] with n = [2, 3] and l = 2.0\nEdge{2, 2, MMJMesh.Geometries.GeometricObjectI}[3] with n = [3, 4] and l = 2.0\nEdge{2, 2, MMJMesh.Geometries.GeometricObjectI}[4] with n = [4, 5] and l = 2.0\n\n\nVarious functions like nodeindices and length exist to access properties. If you are used to an object-oriented language like Java it might be helpful to understand that nodeindices(e) in Julia is equivalent to e.nodeindices() in an OO language.\nNode coordinates are retrieved using the coordinates method:\n\ncoordinates(m)\n\n2×5 Matrix{Float64}:\n 0.0  2.0  4.0  6.0  8.0\n 0.0  0.0  0.0  0.0  0.0\n\n\nProperties are associated with the mesh using the data field of the mesh and a name for the property in the form :name\n\nm.data[:foo] = 99\nm.data[:bar] = sqrt;\n\nand then are ready to be used in a later stage\n\nf = m.data[:bar]\nf(4)\n\n2.0\n\n\nIn Julia, :name is called a symbol. In many applications, this is equivalent to the use of strings like \"name\", however, easier to type.\nIt is easy to plot quantities for nodes\n\nmplot(m, -1 .+ 2 * rand(nnodes(m))) |&gt; mconf()\n\n\n\n\nconstant on elements\n\nmplot(m, -1 .+ 2 * rand(nelements(m))) |&gt; mconf()\n\n\n\n\nlinear on elements\n\nmplot(m, -1 .+ 2 * rand(2, nelements(m))) |&gt; mconf()\n\n\n\n\nfunctions on elements\n\nmplot(m, [Polynomial(rand(-1 .. 1, 4), IHat) for _ ∈ 1:nelements(m)]) |&gt; mconf()\n\n\n\n\nFurthermore, 1D meshes can be created with a parametric function\n\nm = makemeshoninterval(0, 5, 60, t -&gt; [t; 0.3 * sin(π * t)])\nmplot(m) |&gt; mconf()\n\n\n\n\nwhere the last parameter t -&gt; [t; sin(t)] (read: t is mapped on the vector (t, sin(t))) defines the parametric curve\n\\[\n    \\mathbf{u}(t) =\n    \\left(\n    \\begin{array}{c}\n        t\n        \\\\\n        \\sin(t)\n    \\end{array}\n    \\right).\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#demo-for-2d-meshes",
    "href": "index.html#demo-for-2d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.2 Demo for 2D meshes",
    "text": "1.2 Demo for 2D meshes\nCreate mesh on rectangular grid\n\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nmplot(m) |&gt; mconf()\n\n\n\n\nMesh with coordinate transformation\n\ncartesianfrompolar(x) = x[1] * [cos(x[2]), sin(x[2])]\nm = makemeshonrectangle((1 .. 2) × (0 .. (3 / 2)π), 10, 70, gmap=cartesianfrompolar)\nmplot(m, edgesvisible=true) |&gt; mconf()\n\n\n\n\nRead mesh from Gmsh\n\nm = Mesh(meshpath(\"advanced.msh\"))\nmplot(m) |&gt; mconf()\n\n\n\n\nIndices of nodes on boundary\n\nm.groups[:boundarynodes]\n\n12-element NodeGroup:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  9\n 10\n 11\n 12\n 13",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "mesh.html",
    "href": "mesh.html",
    "title": "2  The Mesh interface",
    "section": "",
    "text": "2.1 Basic usage\nCreate mesh\ncoords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]\nelts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]\nm = Mesh(coords, elts, 2)\nmplot(m) |&gt; mconf()\nCoordinates of a node\ncoordinates(node(m, 2))\n\n2-element Vector{Float64}:\n 1.0\n 0.1\nCoordinates of a face\ncoordinates(face(m, 3))\n\n2×3 Matrix{Float64}:\n 1.0  1.9  0.9\n 0.1  0.9  1.0\nProcess faces and print node and edge indices\nfor e ∈ elements(m)\n    println(e)\n    println(\"- \", nodeindices(e))\n    println(\"- \", edgeindices(e))\n    println(\"- \", faceindices(e))\nend\n\nFace{2, 4, MMJMesh.Geometries.GeometricObjectI}[1]\n- [1, 2, 5, 4]\n- [1, 2, 3, 4]\n- [3]\nFace{2, 3, MMJMesh.Geometries.GeometricObjectI}[2]\n- [2, 3, 6]\n- [5, 6, 7]\n- [3]\nFace{2, 3, MMJMesh.Geometries.GeometricObjectI}[3]\n- [2, 6, 5]\n- [7, 8, 2]\n- [1, 2]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "mesh.html#read-mesh-from-gmsh-file",
    "href": "mesh.html#read-mesh-from-gmsh-file",
    "title": "2  The Mesh interface",
    "section": "2.2 Read mesh from Gmsh file",
    "text": "2.2 Read mesh from Gmsh file\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\nmplot(m, edgesvisible=true) |&gt; mconf()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "mesh.html#groups-and-predefined-groups",
    "href": "mesh.html#groups-and-predefined-groups",
    "title": "2  The Mesh interface",
    "section": "2.3 Groups and predefined groups",
    "text": "2.3 Groups and predefined groups\nMesh entities can be collected in groups some of which are predefined.\n\nkeys(m.groups.recipes)\n\nKeySet for a Dict{Symbol, Function} with 7 entries. Keys:\n  :solids\n  :boundaryfaces\n  :faces\n  :nodes\n  :edges\n  :boundaryedges\n  :boundarynodes\n\n\n\nshow(m.groups[:boundarynodes])\n\nNodeGroup[1:19, 31:34, 46:106, 116:157]\n\n\nGroups can be used to filter access\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\np = mplot(m)\nscatter!(p.axis, coordinates(m, :boundarynodes), color = :hotpink)\np |&gt; mconf()\n\n\n\n\nAdditional groups can be defined\n\nm.groups[:f1] = FaceGroup(100:300)\nm.groups[:f2] = FaceGroup(200:600)\nm.groups[:e1] = EdgeGroup(600:800)\nm.groups[:e2] = EdgeGroup(700:900)\nmplot(m) |&gt; mconf()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "mesh.html#data",
    "href": "mesh.html#data",
    "title": "2  The Mesh interface",
    "section": "2.4 Data",
    "text": "2.4 Data\nExample how to attach data to mesh entities:\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\n\nn1 = node(m, 1)\nn2 = node(m, 2)\ne22 = element(m, 22)\nn1.data[:d1] = 42\ne22.data[:d2] = 61\n\nprintln(\" n1.data[:d1] = \", n1.data[:d1])\nprintln(\" n2.data[:d1] = \", n2.data[:d1])\nprintln(\"e22.data[:d2] = \", e22.data[:d2])\n\n n1.data[:d1] = 42\n n2.data[:d1] = nothing\ne22.data[:d2] = 61\n\n\nExample how to attach data to groups:\n\nm = Mesh(meshpath(\"complex-g1.msh\"))\n\nprintln(\"s1: \", m.groups[:s1].indices)\nprintln(\"s2: \", m.groups[:s2].indices)\nprintln(\"s3: \", m.groups[:s3].indices)\n\nm.data[:kefunc, :s1] = \"f1\";\nm.data[:kefunc, :s2] = \"f2\";\nm.data[:kefunc, :s3] = \"f3\";\n\ne0005 = element(m, 0005)\ne0490 = element(m, 0490)\ne1132 = element(m, 1132)\n\nprintln(\"e0005.data[:kefunc] = \", e0005.data[:kefunc])\nprintln(\"e0490.data[:kefunc] = \", e0490.data[:kefunc])\nprintln(\"e1132.data[:kefunc] = \", e1132.data[:kefunc])\n\ns1: [1:488]\ns2: [489:1130]\ns3: [1131:1372]\ne0005.data[:kefunc] = f1\ne0490.data[:kefunc] = f2\ne1132.data[:kefunc] = f3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Mesh interface</span>"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "3  Plotting",
    "section": "",
    "text": "3.1 Plot a 1D mesh",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "plot.html#plot-a-1d-mesh",
    "href": "plot.html#plot-a-1d-mesh",
    "title": "3  Plotting",
    "section": "",
    "text": "3.1.1 On a straight line\n\nm = makemeshoninterval(0, 4, 20)\nmplot(m) |&gt; mconf()\n\n\n\n\nNodes hidden if too many.\n\nm = makemeshoninterval(0, 4, 60)\nmplot(m) |&gt; mconf()\n\n\n\n\nOne value per node\n\nmplot(m, -1.1 .+ 2.6 * rand(nnodes(m))) |&gt; mconf()\n\n\n\n\nOne value per element\n\nmplot(m, -1.1 .+ 2.2 * rand(nedges(m))) |&gt; mconf()\n\n\n\n\nTwo values per element\n\nmplot(m, -1.1 .+ 2.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n3.1.2 Vertical\n\nm = makemeshoninterval(π, 3π, 20, t -&gt; [0; t])\nmplot(m, -1.1 .+ 3.2 * rand(nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n3.1.3 On a spiral\n\nm = makemeshoninterval(π, 3π, 20, t -&gt; t * [cos(t); sin(t)])\nmplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n\n\n\n\n3.1.4 Customize plot\nPlot customization works like this:\n\nf, ax = mplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\nax.title = \"Spiral with reversed vertical axis\"\nax.yreversed = true\nf\n\n\n\n\nDocumentation on plot axis can be found on the Makie documentation which unfortunately is quite hard to read.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "plot.html#plot-a-2d-mesh",
    "href": "plot.html#plot-a-2d-mesh",
    "title": "3  Plotting",
    "section": "3.2 Plot a 2D mesh",
    "text": "3.2 Plot a 2D mesh\n\n3.2.1 Quad mesh\n\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nprintln(\"Number of nodes is Nn = \", (a + 1) * (2a + 1))\nprint(\"Links...\")\n@time l12 = links(m.topology, 1, 2);\n\nNumber of nodes is Nn = 13041\nLinks...  0.062987 seconds (1.11 M allocations: 86.504 MiB, 21.94% compilation time)\n\n\nDefault color\n\nmplot(m, edgesvisible=true, edgecolor=:hotpink) |&gt; mconf()\n\n\n\n\nColors for nodes\n\nmplot(m, 4.1 * (rand(nnodes(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\nColors for elements\n\nmplot(m, 4.1 * (rand(nfaces(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\n\n\n3.2.2 Triangle mesh\n\na = 20\nm = makemeshonrectangle(9.0, 4.5, 2a, a, TRIANGLE)\nprintln(\"Nn = \", (a + 1) * (2a + 1))\nprint(\"Links (1, 2):\")\n@time l12 = links(m.topology, 1, 2);\n\nNn = 861\nLinks (1, 2):  0.007129 seconds (101.73 k allocations: 8.230 MiB, 34.65% compilation time)\n\n\nDefault color\n\nmplot(m, edgesvisible=true) |&gt; mconf()\n\n\n\n\nColors for nodes\n\nmplot(m, 4.1 * (rand(nnodes(m)) .- 0.25)) |&gt; mconf()\n\n\n\n\nColors for elements\n\nmplot(m, 4.1 * (rand(nfaces(m)) .- 0.25)) |&gt; mconf()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "plot.html#plot-functions-on-meshes",
    "href": "plot.html#plot-functions-on-meshes",
    "title": "3  Plotting",
    "section": "3.3 Plot functions on meshes",
    "text": "3.3 Plot functions on meshes\n\n3.3.1 Warp by nodal values\nNodes can be transformed. Either, specify a function which returns the warped coordinates of the node.\n\nm = makemeshonrectangle(4, 2, 20, 10)\nfunction warpfunction(node)\n    x = coordinates(node)\n    return [x..., 0.25 * sin(pi * (x[1] - 2)) * cos(pi * (x[2] - 1))]\nend\n\nf = Figure()\nAxis3(f[1, 1], aspect=:data)\nmplot!(m, rand(nfaces(m)), nodewarp=warpfunction)\nf\n\n\n\n\nAlternatively, use an array to perform a scalar warp.\n\nm = makemeshonrectangle(4, 2, 10, 5)\n\nf = Figure()\nAxis3(f[1, 1], aspect=:data)\nmplot!(m, rand(nfaces(m)), nodewarp=0.25 * rand(nnodes(m)))\nf\n\n\n\n\n\n\n3.3.2 Plot functions on faces\nFor each face, a function from the face geometry reference domain into the real numbers can be provided. Function values are visualized by colors and/or by warping the face.\nThe function is specified by the first parameter to the mplot function, settings are the faceplotXXX named parameters.\nMethod 1: Specify one function:\n\nm = makemeshonrectangle(8, 4, 4, 2)\nw(face) = x -&gt; index(face) * (1 - x[1]^2) * (1 - x[2]^2)\nf = Figure()\nAxis3(f[1, 1], aspect=:data)\nmplot!(m, w, faceplotzscale=0.2, faceplotmesh=2)\nf\n\n\n\n\nMethod 2: Specify postprocessing function, here with the items w and sigma:\n\nfunction results(face, name)\n    if name == :w\n        return x -&gt; index(face) * (1 - x[1]^2) * (1 - x[2]^2)\n    elseif name == :sigma\n        s = Polynomial([0, π])\n        return ProductFunction(Sin() ∘ s, Cos() ∘ s)\n    end\nend\nm.data[:post] = results;\n\nPlot result w:\n\nf = Figure()\nAxis3(f[1, 1], aspect=:data)\nmplot!(m, :w, faceplotzscale=0.2, faceplotmesh=2)\nf\n\n\n\n\nPlot result sigma:\n\nf = Figure()\nAxis3(f[1, 1], aspect=:data)\nmplot!(\n    m, :sigma,\n    faceplotzscale=0.5, faceplotmesh=15, \n    edgelinewidth=2, edgecolor=:red, colormap=:redblue\n)\nf",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "plot.html#plot-options",
    "href": "plot.html#plot-options",
    "title": "3  Plotting",
    "section": "3.4 Plot options",
    "text": "3.4 Plot options\n\na = 10\nm1 = makemeshonrectangle(4, 2, 2a, a)\nmplot(m1, 3 * rand(nfaces(m1)),\n    nodesvisible=true, nodecolor=:hotpink, nodesize=12,\n    edgesvisible=true, edgecolor=:lightblue, edgelinewidth=3,\n    featureedgecolor=:red, featureedgelinewidth=6,\n    facecolormap=:bluesreds\n) |&gt; mconf()\n\n\n\n\n\nm2 = makemeshoninterval(0, 4, 20)\nmplot(m2, rand(nnodes(m2)),\n    lineplotoutlinesvisible=true,\n    edgecolor=:blue, edgelinewidth=10,\n    lineplotscale=0.3,\n    lineplotoutlinescolor=:hotpink,\n    lineplotoutlineslinewidth=2.0,\n    lineplotfacescolormap=:bluesreds\n) |&gt; mconf(title=\"Test Plot\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plotting</span>"
    ]
  },
  {
    "objectID": "mathematics.html",
    "href": "mathematics.html",
    "title": "4  Mathematics",
    "section": "",
    "text": "4.1 Mappings",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mathematics</span>"
    ]
  },
  {
    "objectID": "mathematics.html#mappings",
    "href": "mathematics.html#mappings",
    "title": "4  Mathematics",
    "section": "",
    "text": "4.1.1 Functions \\(\\mathbb{R} \\to \\mathbb{R}\\)\n\nf = Sin() ∘ (1 / Polynomial(0, 1, d=0.0 .. 0.05))\nfplot(f, yscale=0.05, npoints=11)\n\n\n  \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n  \n  \n    \n      \n      \n        \n      \n    \n    \n      \n      \n        \n      \n    \n  \n\n\n\n\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nfplot(c, s, g, p)\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\n\nf = Polynomial([0, 1], -1 .. 1)\nF = antiderivative(f)\nfplot(f, F)\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\n\nintegrate(f, 0 .. 1)\n\n0.5\n\n\n\np = [0, 1, 2]\nf = fplot(fromroots(p, -0.1 .. 2.1))\nscatter!(p, 0 * p, color=:tomato)\nf\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\n\np = [0, 1.5, 2]\nf = fplot(lagrangepolynomials(p, 0 .. 2)...)\nscatter!(p, [0, 0, 0], color=:tomato)\nscatter!(p, [1, 1, 1], color=:blue)\nf\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\n\n\n4.1.2 Parametric curves\nLissajous curve\n\nu = ParametricCurve(Cos(0 .. 2π), Sin() ∘ Polynomial(0, 2, d=0 .. 2pi))\nv = 0.075 * Sin() ∘ Polynomial(0, 100) * UnitNormal(u)\nw = 0.025 * ParametricCurve(Sin(), Cos()) ∘ Polynomial(0, 200)\nfplot(u, u + v, u + w)\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\nInterpolate points\n\npoints = tomatrix([[0.0, 0], [1.5, 1], [2, 0], [1.5, -1], [0, 0]])\nL = lagrangepolynomials(range(IHat, size(points, 2)), IHat)\nu = Interpolation(L, points)\n\nfig, ax = fplot(u)\nscatter!(ax, points, color=:tomato)\nfig\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\n\n\n4.1.3 Monomials\n\nfplot(monomials(0:100, 0 .. 1)...)\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\n\n\n4.1.4 Functions of two variables\nCreate the function \\(f : [0, 5\\pi]^2 \\to \\mathbb{R}, \\quad f(\\mathbf{x}) = \\sin x_1 \\sin x_2\\)\n\nf = makefunction(x -&gt; exp(-hypot(x[1], x[2])^2 / 20) * cos(x[1]) * cos(x[2]), -2π .. 2π, -2π .. 2π);\n\nBy default the plot is a view down from positive \\(z\\) direction\n\nfplot3d(f, mesh=9)\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\nCreate a 3D plot using Axis3 and switch of the mesh off since CairoMakie does not handle hidden lines.\n\nfig = Figure()\nAxis3(fig[1, 1])\nfplot3d!(f, npoints=250, mesh=nothing)\nfig\n\n\n  \n    \n    \n      \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\nA (sometimes?) interactive 3D plot is obtained using WebGL:\n\nGLMakie.activate!()\nfig = Figure()\nAxis3(fig[1, 1])\nfplot3d!(f, mesh=19, npoints=250)\nfig\n\n\n\n\nMultivariate polynomial \\(f(x, y) = x^2 y - y\\)\n\ng = MPolynomial([2 1; 0 1], [1.0, -1.0], QHat)\nfig = Figure()\nAxis3(fig[1, 1])\nfplot3d!(g)\nfig\n\n\n\n\nMultivariate monomials\n\nfplot3d(mmonomials(2, 3, QHat))\n\n\n\n\nPlot gradient of product function\n\nCairoMakie.activate!()\ng = ProductFunction(Sin(0 .. 2π), Sin(0 .. 2π))\nfig = Figure()\nAxis(fig[1, 1])\nfplot3d!(g, mesh=nothing)\nvplot!(gradient(g), npoints=9, lengthscale=0.3)\nfig",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mathematics</span>"
    ]
  },
  {
    "objectID": "sampling.html",
    "href": "sampling.html",
    "title": "5  Adaptive sampling",
    "section": "",
    "text": "Plot function\n\nfunction doplot(xy)\n    f = lines(xy)\n    scatter!(xy, color=:darkred, markersize=5)\n    return f\nend;\n\nLinear function\n\nsample1d(x -&gt; x, -1, 1) |&gt; doplot\n\n\n\n\nParabola\n\nsample1d(x -&gt; x^2, -1, 1) |&gt; doplot\n\n\n\n\nCurved in one region\n\nsample1d(x -&gt; x^100, 0, 1) |&gt; doplot\n\n\n\n\nSingular point\n\nsample1d(x -&gt; sin(1.0 / x), 0.0, 0.05, maxangle=0.05, npoints=21) |&gt; doplot\n\n\n\n\n\nsample1d(x -&gt; sin(1.0 / x), 0.0, 0.05, yscale=0.05, npoints=21) |&gt; doplot\n\n\n\n\n\n@time size(sample1d(x -&gt; sin(1.0 / x), 0.0, 0.05, maxangle=0.1), 2)\n\n  0.043507 seconds (353.86 k allocations: 7.730 MiB, 17.84% compilation time)\n\n\n8479\n\n\nMultiple curvatures\n\nsample1d(x -&gt; sin(30 * sin(x)), 0, 2pi) |&gt; doplot\n\n\n\n\nDiscontinuity\n\nsample1d(x -&gt; 1 / x, 0, 1, yscale=1e-5) |&gt; doplot\n\n\n\n\nInsert root\n\nsample1d(x -&gt; (-0.3 + x), -1, 1, ir=true) |&gt; doplot\n\n\n\n\nNon smooth function\n\nsample1d(x -&gt; abs(x), -1, 1) |&gt; doplot\n\n\n\n\nLocal peak\n\na = 0.01\nf = Polynomial(0, 1, d=-1 .. 1) + a^2 / Polynomial(a^2, 0.0, 1.0)\nsample1d(f, -1, 1) |&gt; doplot\n\n\n\n\nCircle\n\nu = ParametricCurve(Cos(0 .. 2π), Sin(0 .. 2π))\nsample1d(u, 0, 2pi) |&gt; doplot",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adaptive sampling</span>"
    ]
  },
  {
    "objectID": "finite-elements.html",
    "href": "finite-elements.html",
    "title": "6  Finite elements",
    "section": "",
    "text": "6.1 Elements\nfig = Figure(size=(800, 800))\nAxis(fig)\nfeplot(fig[1, 1], makeelement(:lagrange, IHat, k=1)) |&gt; feconf()\nfeplot(fig[1, 2], makeelement(:lagrange, IHat, k=3)) |&gt; feconf()\nfeplot(fig[2, 1], makeelement(:hermite, IHat)) |&gt; feconf()\nfeplot(fig[2, 2], makeelement(:lagrange, QHat, k=1)) |&gt; feconf()\nfeplot(fig[3, 1], makeelement(:lagrange, QHat, k=2)) |&gt; feconf()\nfeplot(fig[3, 2], makeelement(:serendipity, QHat, k=2)) |&gt; feconf()\nfeplot(fig[4, 1], makeelement(:hermite, QHat, conforming=true)) |&gt; feconf()\nfeplot(fig[4, 2], makeelement(:hermite, QHat, conforming=false)) |&gt; feconf()\nfig",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Finite elements</span>"
    ]
  },
  {
    "objectID": "finite-elements.html#shape-functions",
    "href": "finite-elements.html#shape-functions",
    "title": "6  Finite elements",
    "section": "6.2 Shape functions",
    "text": "6.2 Shape functions\nLinear shape functions\n\ne = makeelement(:lagrange, IHat, k=1)\nϕ = nodalbasis(e)\nfplot(ϕ...)\n\n\n\n\nHermite polynomials\n\ne = makeelement(:hermite, 1 .. 4)\nϕ = nodalbasis(e)\nfplot(ϕ...)\n\n\n\n\nBilinear shape functions\n\nmakeelement(:lagrange, QHat, k=1) |&gt; nodalbasis |&gt; fplot3d\n\n\n\n\nSerendipity shape functions\n\nmakeelement(:serendipity, (0 .. 2) × (0 .. 1), k=2) |&gt; nodalbasis |&gt; fplot3d\n\n\n\n\nConforming rectangular plate element shape functions\n\nmakeelement(:hermite, QHat) |&gt; nodalbasis |&gt; fplot3d",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Finite elements</span>"
    ]
  },
  {
    "objectID": "finite-elements.html#finite-element-stiffness-matrices",
    "href": "finite-elements.html#finite-element-stiffness-matrices",
    "title": "6  Finite elements",
    "section": "6.3 Finite element stiffness matrices",
    "text": "6.3 Finite element stiffness matrices\n\n@variables l, a, b, EA, EI, ν;\n\n\n6.3.1 Truss\n\nL11 = nodalbasis(makeelement(:lagrange, IHat, k=1))\nD(u) = 2 / l * u'\nae(u, δu) = EA * l / 2 * integrate(D(u) * D(δu), IHat)\nKe = simplify.([ae(s1, s2) for s1 ∈ L11, s2 ∈ L11])\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cc}\n\\frac{EA}{l} & \\frac{ - EA}{l} \\\\\n\\frac{ - EA}{l} & \\frac{EA}{l} \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\n\n\n6.3.2 Beam\n\nH1 = nodalbasis(makeelement(:hermite, IHat))\nH1l = [H1[1], l / 2 * H1[2], H1[3], l / 2 * H1[4]]\nD(w) = 4 / l^2 * w''\nae(w, δw) = EI * l / 2 * integrate(D(w) * D(δw), IHat)\nKe = simplify.(l^3 / EI * [ae(s1, s2) for s1 ∈ H1l, s2 ∈ H1l])\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cccc}\n12 & 6 l & -12 & 6 l \\\\\n6 l & 4 l^{2} &  - 6 l & 2 l^{2} \\\\\n-12 &  - 6 l & 12 &  - 6 l \\\\\n6 l & 2 l^{2} &  - 6 l & 4 l^{2} \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\n\n\n6.3.3 2D Poisson equation\nIntegration on the reference quadrilateral\n\nL21 = nodalbasis(makeelement(:lagrange, QHat, k=1))\nD(u) = [2 / a * ∂x(u), 2 / b * ∂y(u)]\nae(u, v) = a * b / 4 * integrate(D(u) ⋅ D(v), QHat)\nKe = simplify.(6 * a * b * [ae(n1, n2) for n1 ∈ L21, n2 ∈ L21], expand=true)\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cccc}\n2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} &  - a^{2} - b^{2} &  - 2 a^{2} + b^{2} \\\\\na^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) &  - 2 a^{2} + b^{2} &  - a^{2} - b^{2} \\\\\n- a^{2} - b^{2} &  - 2 a^{2} + b^{2} & 2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} \\\\\n- 2 a^{2} + b^{2} &  - a^{2} - b^{2} & a^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nAlternative derivation in physical coordinates\n\nV = [0 a a 0; 0 0 b b]\nN = [ValueAtLF(p) for p in eachcol(V)]\nPP = mmonomials(2, 1, QHat)\nM = [n(p) for p in PP, n in N]\nL21p = inv(M) * PP\n\nae(u, v) = integrate(∇(u) ⋅ ∇(v), (0 .. a) × (0 .. b))\nKe = simplify.(expand.(6 * a * b * [ae(n1, n2) for n1 ∈ L21p, n2 ∈ L21p]))\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{cccc}\n2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} &  - a^{2} - b^{2} &  - 2 a^{2} + b^{2} \\\\\na^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) &  - 2 a^{2} + b^{2} &  - a^{2} - b^{2} \\\\\n- a^{2} - b^{2} &  - 2 a^{2} + b^{2} & 2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} \\\\\n- 2 a^{2} + b^{2} &  - a^{2} - b^{2} & a^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nNicely formatted output. TODO: Handle LaTeX-String from latexify\n\\[\n    \\mathbf{K}^\\mathrm{e} = \\frac{1}{6ab} \\cdot L\"\\left[\n\\begin{array}{cccc}\n2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} &  - a^{2} - b^{2} &  - 2 a^{2} + b^{2} \\\\\na^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) &  - 2 a^{2} + b^{2} &  - a^{2} - b^{2} \\\\\n- a^{2} - b^{2} &  - 2 a^{2} + b^{2} & 2 \\left( a^{2} + b^{2} \\right) & a^{2} - 2 b^{2} \\\\\n- 2 a^{2} + b^{2} &  - a^{2} - b^{2} & a^{2} - 2 b^{2} & 2 \\left( a^{2} + b^{2} \\right) \\\\\n\\end{array}\n\\right]\"\n\\]\n\nbe(v) = integrate(v, (0 .. a) × (0 .. b))\nre = simplify.(expand.([be(n1) for n1 ∈ L21p]))\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{c}\n\\frac{1}{4} a b \\\\\n\\frac{1}{4} a b \\\\\n\\frac{1}{4} a b \\\\\n\\frac{1}{4} a b \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Finite elements</span>"
    ]
  }
]