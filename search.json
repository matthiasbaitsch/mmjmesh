[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The MMJMesh Library",
    "section": "",
    "text": "1 Introduction\nThe MMJMesh library is intended to become a simple yet versatile basis for the implementation of finite element methods or postprocessing tools. At the moment it is in a very early stage of development."
  },
  {
    "objectID": "index.html#demo-for-1d-meshes",
    "href": "index.html#demo-for-1d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.1 Demo for 1D meshes",
    "text": "1.1 Demo for 1D meshes\nFirst, we need to load the required modules. Note that CairoMakie included by import and not by using in order to avoid name collissions.\n#| warning: false\nimport CairoMakie\nusing MMJMesh.Plots\nusing MMJMesh.Meshes\nusing MMJMesh.Utilities\n#| echo: false\nCairoMakie.set_theme!(CairoMakie.theme_minimal())\nIn the simplest case, a 1D mesh is defined by parameter bounds and the number of elements.\nm = makemeshoninterval(0.0, 8.0, 4)\nmplot(m) |&gt; mconf()\nElements of the mesh can be easily processed in a loop:\nfor e ∈ elements(m)\n    println(e, \" with n = \", nodeIdxs(e), \" and l = \", length(e))\nend\nVarious functions like nodeIdxs and length exist to access properties. If you are used to an object-oriented language like Java it might be helpful to understand that nodeIdxs(e) in Julia is equivalent to e.nodeIdxs() in an OO language.\nNode coordinates are retrieved using the coordinates method:\ncoordinates(m)\nProperties are associated with the mesh using the data field of the mesh and a name for the property in the form :name\nm.data[:foo] = 99\nm.data[:bar] = sqrt;\nand then are ready to be used in a later stage\nf = m.data[:bar]\nf(4)\nIn Julia, :name is called a symbol. In many applications, this is equivalent to the use of strings like \"name\", however, easier to type.\nIt is easy to plot quantities for nodes\nmplot(m, -1 .+ 2 * rand(nnodes(m))) |&gt; mconf()\nconstant on elements\nmplot(m, -1 .+ 2 * rand(nelements(m))) |&gt; mconf()\nor linear on elements\nmplot(m, -1 .+ 2 * rand(2, nelements(m))) |&gt; mconf()\nFurthermore, 1D meshes can be created with a parametric function\nm = makemeshoninterval(0, 5, 60, t -&gt; [t; 0.3 * sin(π * t)])\nmplot(m) |&gt; mconf()\nwhere the last parameter t -&gt; [t; sin(t)] (read: t is mapped on the vector (t, sin(t))) defines the parametric curve\n\\[\n    \\mathbf{u}(t) =\n    \\left(\n    \\begin{array}{c}\n        t\n        \\\\\n        \\sin(t)\n    \\end{array}\n    \\right).\n\\]"
  },
  {
    "objectID": "mesh.html",
    "href": "mesh.html",
    "title": "2  The Mesh interface",
    "section": "",
    "text": "This chapter is incomplete and probably not worth reading.\n#| echo: false\n#| warning: false\ninclude(\"setup.jl\")\nCreate mesh\ncoords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]\nelts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]\nm = Mesh(coords, elts, 2)\n\nmplot(m)\nCoordinates of a node\ncoordinates(node(m, 2))\nCoordinates of a face\ncoordinates(face(m, 3))\nProcess faces and print node and edge indexes\nfor e ∈ elements(m)\n    println(e)\n    println(\"- \", nodeIdxs(e))\n    println(\"- \", edgeIdxs(e))\n    println(\"- \", faceIdxs(e))\nend"
  },
  {
    "objectID": "plot.html#plot-a-1d-mesh",
    "href": "plot.html#plot-a-1d-mesh",
    "title": "3  Plotting",
    "section": "3.1 Plot a 1D mesh",
    "text": "3.1 Plot a 1D mesh\n\n3.1.1 On a straight line\nm = makemeshoninterval(0, 4, 20)\nmplot(m, nodecolor=:green) |&gt; mconf()\nOne value per node\nmplot(m, -1.1 .+ 2.6 * rand(nentities(m.topology, 0))) |&gt; mconf()\nOne value per element\nmplot(m, -1.1 .+ 2.2 * rand(nedges(m))) |&gt; mconf()\nTwo values per element\nmplot(m, -1.1 .+ 2.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n3.1.2 Vertical\nm = makemeshoninterval(π, 3π, 20, t -&gt; [0; t])\nmplot(m, -1.1 .+ 3.2 * rand(nedges(m))) |&gt; mconf()\n\n\n3.1.3 On a spiral\nm = makemeshoninterval(π, 3π, 20, t -&gt; t * [cos(t); sin(t)])\nmplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\n\n\n3.1.4 Customize plot\nPlot customization works like this:\nf, ax = mplot(m, -1.1 .+ 3.2 * rand(2, nedges(m))) |&gt; mconf()\nax.title = \"Spiral with reversed vertical axis\"\nax.yreversed = true\nf\nDocumentation on plot axis can be found on the Makie documentation which unfortunately is quite hard to read."
  },
  {
    "objectID": "plot.html#plot-a-2d-mesh",
    "href": "plot.html#plot-a-2d-mesh",
    "title": "3  Plotting",
    "section": "3.2 Plot a 2D mesh",
    "text": "3.2 Plot a 2D mesh\n\n3.2.1 Quad mesh\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nprintln(\"Number of nodes is Nn = \", (a + 1) * (2a + 1))\nprint(\"Links...\")\n@time l12 = links(m.topology, 1, 2);\nDefault color\nmplot(m, showedges=true, edgecolor=:hotpink) |&gt; mconf()\nColors for nodes\nmplot(m, 4.1 * (rand(nentities(m.topology, 0)) .- 0.25)) |&gt; mconf()\nColors for elements\nmplot(m, 4.1 * (rand(nentities(m.topology, 2)) .- 0.25)) |&gt; mconf()\n\n\n3.2.2 Triangle mesh\na = 20\nm = makemeshonrectangle(9.0, 4.5, 2a, a, TRIANGLE)\nprintln(\"Nn = \", (a + 1) * (2a + 1))\nprint(\"Links (1, 2):\")\n@time l12 = links(m.topology, 1, 2);\nDefault color\nmplot(m, showedges=true) |&gt; mconf()\nColors for nodes\nmplot(m, 4.1 * (rand(nentities(m.topology, 0)) .- 0.25)) |&gt; mconf()\nColors for elements\nmplot(m, 4.1 * (rand(nentities(m.topology, 2)) .- 0.25)) |&gt; mconf()"
  },
  {
    "objectID": "plot.html#plot-options",
    "href": "plot.html#plot-options",
    "title": "3  Plotting",
    "section": "3.3 Plot options",
    "text": "3.3 Plot options\na = 10\nm1 = makemeshonrectangle(4, 2, 2a, a)\nmplot(m1, 3 * rand(nfaces(m1)),\n    shownodes=true, nodecolor=:hotpink, nodesize=12,\n    showedges=true,edgecolor=:lightblue, edgelinewidth=3,\n    featureedgecolor=:red, featureedgelinewidth=6,\n    facecolormap=:bluesreds\n) |&gt; mconf()\nm2 = makemeshoninterval(0, 4, 20)\nmplot(m2, rand(nnodes(m2)),\n    showlineplotoutlines=true,\n    edgecolor=:blue, edgelinewidth=10,\n    lineplotscale=0.3,\n    lineplotoutlinescolor=:hotpink,\n    lineplotoutlineslinewidth=2.0,\n    lineplotfacescolormap=:bluesreds\n) |&gt; mconf(title=\"Test Plot\")"
  },
  {
    "objectID": "mathematics.html#mappings",
    "href": "mathematics.html#mappings",
    "title": "4  Mathematics",
    "section": "4.1 Mappings",
    "text": "4.1 Mappings\ns = Sin(0 .. 3π)\nc = Cos(0 .. 3π)\n\nf = 2s\ng = s + f'\np = 1 / 20 * Polynomial([2, -1], 1 .. 8) * Polynomial([3, -1]) * Polynomial([4.5, -1]) * Polynomial([8, -1])\n\nplot(c, s, g, p)\n\n4.1.1 Monomials\nplot(monomials(0:100, 0 .. 1)...)\n\n\n4.1.2 Hermite like polynomials with middle node\nDefine linear forms\nstruct ValueAt &lt;: AbstractMapping{AbstractMapping,Real,Everything()}\n    x::Real\nend\nMMJMesh.Mathematics.valueat(u::ValueAt, f) = f(u.x)\n\nstruct DerivativeAt &lt;: AbstractMapping{AbstractMapping,Real,Everything()}\n    x::Real\nend\nMMJMesh.Mathematics.valueat(u::DerivativeAt, f) = f'(u.x)\nCompute polynomials from Vandermonde matrix\nh = 2.0\nN = [ValueAt.(0:h/2:h); DerivativeAt.([0, h])] |&gt; vcat\nP = monomials(0:length(N)-1, 0 .. h)\nM = [n(p) for p in P, n in N]\nH = inv(M) * P\nplot(H...)"
  }
]