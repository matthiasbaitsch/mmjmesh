[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The MMJMesh Library",
    "section": "",
    "text": "1 Introduction\nThe MMJMesh library is intended to become a simple yet versatile basis for the implementation of finite element methods or postprocessing tools. At the moment it is in a very early stage of development."
  },
  {
    "objectID": "index.html#demo-for-1d-meshes",
    "href": "index.html#demo-for-1d-meshes",
    "title": "The MMJMesh Library",
    "section": "1.1 Demo for 1D meshes",
    "text": "1.1 Demo for 1D meshes\nFirst, we need to load the required modules. Note that CairoMakie included by import and not by using in order to avoid name collissions.\n#| warning: false\nimport CairoMakie\nusing MMJMesh.Plots\nusing MMJMesh.Meshes\nusing MMJMesh.Utilities\n#| echo: false\nCairoMakie.set_theme!(CairoMakie.theme_minimal())\nIn the simplest case, a 1D mesh is defined by parameter bounds and the number of elements.\nm = makemeshoninterval(0.0, 8.0, 4)\nplot(m)\nElements of the mesh can be easily processed in a loop:\nfor e ∈ elements(m)\n    println(e, \" with n = \", nodeIdxs(e), \" and l = \", length(e))\nend\nVarious functions like nodeIdxs and length exist to access properties. If you are used to an object-oriented language like Java it might be helpful to understand that nodeIdxs(e) in Julia is equivalent to e.nodeIdxs() in an OO language.\nNode coordinates are retrieved using the coordinates method:\ncoordinates(m)\nProperties are associated with the mesh using the data field of the mesh and a name for the property in the form :name\n#| echo: false\nm.data[:foo] = 99\nm.data[:bar] = sqrt\nand then are ready to be used in a later stage\nf = m.data[:bar]\nf(4)\nIn Julia, :name is called a symbol. In many applications, this is equivalent to the use of strings like \"name\", however, easier to type.\nIt is easy to plot quantities for nodes\nplot(m, -1 .+ 2 * rand(nnodes(m)))\nconstant on elements\nplot(m, -1 .+ 2 * rand(nelements(m)))\nor linear on elements\nplot(m, -1 .+ 2 * rand(2, nelements(m)))\nFurthermore, 1D meshes can be created with a parametric function\nm = makemeshoninterval(0, 4, 60, t -&gt; [t; sin(π * t)])\nplot(m)\nwhere the last parameter t -&gt; [t; sin(t)] (read: t is mapped on the vector (t, sin(t))) defines the parametric curve\n\\[\n    \\mathbf{u}(t) =\n    \\left(\n    \\begin{array}{c}\n        t\n        \\\\\n        \\sin(t)\n    \\end{array}\n    \\right).\n\\]"
  },
  {
    "objectID": "mesh.html",
    "href": "mesh.html",
    "title": "2  The Mesh interface",
    "section": "",
    "text": "This chapter is incomplete and probably not worth reading.\n#| echo: false\n#| warning: false\ninclude(\"setup.jl\")\nCreate mesh\ncoords = [0.0 1.0 2.0 0.1 0.9 1.9; 0.0 0.1 0.0 0.9 1.0 0.9]\nelts = [[1, 2, 5, 4], [2, 3, 6], [2, 6, 5]]\nm = Mesh(coords, elts, 2)\n\nplot(m)\nCoordinates of a node\ncoordinates(node(m, 2))\nCoordinates of a face\ncoordinates(face(m, 3))\nProcess faces and print node and edge indexes\nfor e ∈ elements(m)\n    println(e)\n    println(\"- \", nodeIdxs(e))\n    println(\"- \", edgeIdxs(e))\n    println(\"- \", faceIdxs(e))\nend"
  },
  {
    "objectID": "plot.html#plot-a-1d-mesh",
    "href": "plot.html#plot-a-1d-mesh",
    "title": "3  Plotting",
    "section": "3.1 Plot a 1D mesh",
    "text": "3.1 Plot a 1D mesh\n\n3.1.1 On a straight line\nm = makemeshoninterval(0, 4, 20)\nplot(m)\nOne value per node\nplot(m, -1.1 .+ 2.2 * rand(nentities(m.topology, 0)))\nOne value per element\nplot(m, -1.1 .+ 2.2 * rand(nedges(m)))\nTwo values per element\nplot(m, -1.1 .+ 2.2 * rand(2, nedges(m)))\n\n\n3.1.2 Vertical\nm = makemeshoninterval(π, 3π, 20, t -&gt; [0; t])\nplot(m, -1.1 .+ 3.2 * rand(nedges(m)))\n\n\n3.1.3 On a spiral\nm = makemeshoninterval(π, 3π, 20, t -&gt; t * [cos(t); sin(t)])\nplot(m, -1.1 .+ 3.2 * rand(2, nedges(m)))\n\n\n3.1.4 Customize plot\nPlot customization works like this:\nf = plot(m, -1.1 .+ 3.2 * rand(2, nedges(m)))\nax = f.content[1]\nax.title = \"Spiral with reversed vertical axis\"\nax.yreversed = true\nf\nDocumentation on plot axis can be found on the Makie documentation which unfortunately is quite hard to read."
  },
  {
    "objectID": "plot.html#plot-a-2d-mesh",
    "href": "plot.html#plot-a-2d-mesh",
    "title": "3  Plotting",
    "section": "3.2 Plot a 2D mesh",
    "text": "3.2 Plot a 2D mesh\n\n3.2.1 Quad mesh\na = 80\nm = makemeshonrectangle(9.0, 4.5, 2a, a)\nprintln(\"Number of nodes is Nn = \", (a + 1) * (2a + 1))\nprint(\"Links...\")\n@time l12 = links(m.topology, 1, 2);\nDefault color\nps = PlotStyle(m)\nps.edges.outlineonly = false\nps.edges.color = :hotpink\nplot(m, ps)\nColors for nodes\nplot(m, 4.1 * (rand(nentities(m.topology, 0)) .- 0.25))\nColors for elements\nplot(m, 4.1 * (rand(nentities(m.topology, 2)) .- 0.25))\n\n\n3.2.2 Triangle mesh\na = 20\nm = makemeshonrectangle(9.0, 4.5, 2a, a, TRIANGLE)\nprintln(\"Nn = \", (a + 1) * (2a + 1))\nprint(\"Links (1, 2):\")\n@time l12 = links(m.topology, 1, 2);\nDefault color\nps = PlotStyle(m)\nps.edges.outlineonly = false\nps.edges.color = :hotpink\nplot(m, ps)\nColors for nodes\nplot(m, 4.1 * (rand(nentities(m.topology, 0)) .- 0.25))\nColors for elements\nplot(m, 4.1 * (rand(nentities(m.topology, 2)) .- 0.25))"
  }
]